<!doctype html>
<html lang="zh-CN" dir="ltr" class="blog-wrapper blog-tags-post-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">6 篇博文 含有标签「Meetup」 | Apache SeaTunnel</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://seatunnel.apache.org/zh-CN/blog/tags/meetup"><meta data-rh="true" name="docusaurus_locale" content="zh-CN"><meta data-rh="true" name="docsearch:language" content="zh-CN"><meta data-rh="true" property="og:title" content="6 篇博文 含有标签「Meetup」 | Apache SeaTunnel"><meta data-rh="true" name="docusaurus_tag" content="blog_tags_posts"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_tags_posts"><link data-rh="true" rel="icon" href="/zh-CN/image/favicon.ico"><link data-rh="true" rel="canonical" href="https://seatunnel.apache.org/zh-CN/blog/tags/meetup"><link data-rh="true" rel="alternate" href="https://seatunnel.apache.org/blog/tags/meetup" hreflang="en"><link data-rh="true" rel="alternate" href="https://seatunnel.apache.org/zh-CN/blog/tags/meetup" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://seatunnel.apache.org/blog/tags/meetup" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/zh-CN/blog/rss.xml" title="Apache SeaTunnel RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh-CN/blog/atom.xml" title="Apache SeaTunnel Atom Feed">






<link rel="alternate" type="application/rss+xml" href="/zh-CN/user_cases/rss.xml" title="Apache SeaTunnel RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh-CN/user_cases/atom.xml" title="Apache SeaTunnel Atom Feed">

<script>var _paq=window._paq=window._paq||[];_paq.push(["setDoNotTrack",!0]),_paq.push(["disableCookies"]),_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){var a="https://analytics.apache.org/";_paq.push(["setTrackerUrl",a+"matomo.php"]),_paq.push(["setSiteId","65"]);var e=document,p=e.createElement("script"),t=e.getElementsByTagName("script")[0];p.async=!0,p.src=a+"matomo.js",t.parentNode.insertBefore(p,t)}()</script><link rel="stylesheet" href="/zh-CN/assets/css/styles.1d2cde9b.css">
<link rel="preload" href="/zh-CN/assets/js/runtime~main.493b0a68.js" as="script">
<link rel="preload" href="/zh-CN/assets/js/main.ae1b2d26.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,t("light"))}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><div class="announcementBar_mb4j" style="background-color:rgb(70, 125, 175, 0.8)" role="banner"><div class="content_knG7 announcementBarContent_xLdY"><a href="https://github.com/apache/seatunnel" target="_blank" style="display: flex; width: 100%; align-items: center; justify-content: center; margin-left: 4px; text-decoration: none;">⭐️ If you like Apache SeaTunnel, give it a star on GitHub 
                <img style="width: 1.2rem; height: 1.2rem; margin-left: 0.4rem;" src="/home/icons/github1.svg"> ⭐️
                    </a></div></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/zh-CN/"><div class="navbar__logo"><img src="/zh-CN/image/logo.png" alt="Apache SeaTunnel Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/zh-CN/image/logo.png" alt="Apache SeaTunnel Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Apache SeaTunnel</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/zh-CN/">首页</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">文档</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/zh-CN/docs/2.3.9/about">2.3.9</a></li><li><a class="dropdown__link" href="/zh-CN/docs/2.3.8/about">2.3.8</a></li><li><a class="dropdown__link" href="/zh-CN/docs/2.3.7/about">2.3.7</a></li><li><a class="dropdown__link" href="/zh-CN/docs/2.3.6/about">2.3.6</a></li><li><a class="dropdown__link" href="/zh-CN/docs/2.3.5/about">2.3.5</a></li><li><a class="dropdown__link" href="/zh-CN/docs/about">Next</a></li><li><a class="dropdown__link" href="/zh-CN/versions/">All versions</a></li></ul></div><a class="navbar__item navbar__link" href="/zh-CN/download">下载</a><a class="navbar__item navbar__link" href="/zh-CN/community/contribution_guide/contribute">社区</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/zh-CN/blog">博客</a><a class="navbar__item navbar__link" href="/zh-CN/user_cases">用户案例</a><a class="navbar__item navbar__link" href="/zh-CN/team">团队</a><a class="navbar__item navbar__link" href="/zh-CN/user">用户</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Apache</a><ul class="dropdown__menu"><li><a href="https://www.apache.org/" target="_blank" rel="noopener noreferrer" class="dropdown__link">基金会</a></li><li><a href="https://www.apache.org/licenses/" target="_blank" rel="noopener noreferrer" class="dropdown__link">证书</a></li><li><a href="https://www.apache.org/events/current-event" target="_blank" rel="noopener noreferrer" class="dropdown__link">事件</a></li><li><a href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">赞助</a></li><li><a href="https://www.apache.org/foundation/thanks.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">致谢</a></li><li><a href="https://apache.org/foundation/policies/privacy.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Privacy</a></li></ul></div><a href="https://github.com/apache/incubator-seatunnel" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a class="navbar__item navbar__link" href="/zh-CN/security">安全</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>简体中文</a><ul class="dropdown__menu"><li><a href="/blog/tags/meetup" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li><li><a href="/zh-CN/blog/tags/meetup" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-CN">简体中文</a></li></ul></div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="搜索" aria-label="Search" class="navbar__search-input searchInput_YFbd"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-CN/blog/2023/3/31/SeaTunnel_2_3_1_Released_Refactored_AI_Compatible_Feature_Allows_ChatGPT_Automatic_Get">SeaTunnel 2.3.1 is released! The refactored AI Compatible feature allows ChatGPT to automatically generate Connector code</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-CN/blog/2023/3/29/Performance_Test_Report_SeaTunnel_Synchronizes_Data_in_Batches_420_Percent_Faster_than_GLUE.md">Performance Test Report: SeaTunnel Synchronizes data in batches 420% Faster than GLUE!</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-CN/blog/2023/02/09/SeaTunnel_Now_Supports_CDC_Writing_by_ClickHouse_Connector.md">SeaTunnel now supports CDC (Capture Change Data) writing by ClickHouse Connector!</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-CN/blog/Reveal the core design of the SeaTunnel Zeta synchronization engine!">In the recently released SeaTunnel 2.3.0 official version</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-CN/blog/Apache IoTDB (Internet of Things Database) is a software system that integrates the collection">SeaTunnel supports IoTDB to implement IoT data synchronization</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><header class="margin-bottom--xl"><h1>6 篇博文 含有标签「Meetup」</h1><a href="/zh-CN/blog/tags">查看所有标签</a></header><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="In the recently released SeaTunnel 2.3.0 official version, the community self-developed engine SeaTunnel Zeta which has been under preparation for more than a year——is officially released, and it will be used as the default engine of SeaTunnel in the future, providing users with high throughput, low latency, reliable consistent synchronization job operation guarantee."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-CN/blog/Reveal the core design of the SeaTunnel Zeta synchronization engine!">In the recently released SeaTunnel 2.3.0 official version</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-01-10T00:00:00.000Z" itemprop="datePublished">2023年1月10日</time> · <!-- -->阅读需 12 分钟</div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="/zh-CN/assets/images/16733443077196-048cdae0ce9892c195e1c6ca1374cfc5.png" width="900" height="383" class="img_ev3q"></p><p>In the recently released SeaTunnel 2.3.0 official version, the community self-developed engine SeaTunnel Zeta which has been under preparation for more than a year——is officially released, and it will be used as the default engine of SeaTunnel in the future, providing users with high throughput, low latency, reliable consistent synchronization job operation guarantee.</p><p>Why does SeaTunnel develop its synchronization engine? What is the positioning of the SeaTunnel Engine? How is it different from traditional computing engines? What is the design idea? What is unique about the architectural design? These questions will be answered in this article.</p><ul><li>Why develop our engine</li><li>SeaTunnel Engine Positioning</li><li>Design ideas</li><li>Architecture design</li><li>Unique advantages and features</li><li>Current basic functions and features</li><li>Future optimization plan</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="01-why-develop-our-engine">01 Why develop our engine<a href="#01-why-develop-our-engine" class="hash-link" aria-label="01 Why develop our engine的直接链接" title="01 Why develop our engine的直接链接">​</a></h2><p>It was a year ago that the SeaTunnel community publicly stated for the first time that it would develop its engine. The reason why the team decided to develop a self-developed engine was that SeaTunnel&#x27;s connector can run only on Flink or Spark, and Flink and Spark, as computing engines, have many unsolvable problems when integrating and synchronizing data.</p><p>Refer to:
Why do we self-develop the big data synchronization engine SeaTunnel Zeta?
<a href="https://github.com/apache/incubator-seatunnel/issues/1954" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/issues/1954</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="02-design-ideas">02 Design ideas<a href="#02-design-ideas" class="hash-link" aria-label="02 Design ideas的直接链接" title="02 Design ideas的直接链接">​</a></h2><p>The general idea of engine design is as follows:</p><ol><li>Simple and easy to use, the new engine minimizes the dependence on third-party services, and can realize cluster management, snapshot storage, and cluster HA functions without relying on big data components such as Zookeeper and HDFS. This is very useful for users who do not have a big data platform or are unwilling to rely on a big data platform for data synchronization.</li><li>More resource-saving, at the CPU level, Zeta Engine internally uses Dynamic Thread Sharing (dynamic thread sharing) technology. In the real-time synchronization scenario, if the number of tables is large but the amount of data in each table is small, Zeta Engine will Synchronous tasks run in shared threads, which can reduce unnecessary thread creation and save system resources. On the read and data write side, the Zeta Engine is designed to minimize the number of JDBC connections. In the CDC scenario, Zeta Engine will try to reuse log reading and parsing resources as much as possible.</li><li>More stable. In this version, Zeta Engine uses Pipeline as the minimum granularity of Checkpoint and fault tolerance for data synchronization tasks. The failure of a task will only affect the tasks that have upstream and downstream relationships with it. Try to avoid task failures that cause the entire Job to fail. or rollback. At the same time, for scenarios where the source data has a storage time limit, Zeta Engine supports enabling data cache to automatically cache the data read from the source, and then the downstream tasks read the cached data and write it to the target. In this scenario, even if the target end fails and data cannot be written, it will not affect the normal reading of the source end, preventing the source end data from being deleted due to expiration.</li><li>Faster, Zeta Engine’s execution plan optimizer will optimize the execution plan to reduce the possible network transmission of data, thereby reducing the loss of overall synchronization performance caused by data serialization and deserialization, and completing faster Data synchronization operations. Of course, it also supports speed limiting, so that sync jobs can be performed at a reasonable speed.</li><li>Data synchronization support for all scenarios. SeaTunnel aims to support full synchronization and incremental synchronization under offline batch synchronization, and support real-time synchronization and CDC.</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="03-architecture-design">03 Architecture design<a href="#03-architecture-design" class="hash-link" aria-label="03 Architecture design的直接链接" title="03 Architecture design的直接链接">​</a></h2><p>SeaTunnel Engine is mainly composed of a set of APIs for data synchronization processing and a core computing engine. Here we mainly introduce the architecture design of the SeaTunnel Engine core engine.
<img loading="lazy" src="/zh-CN/assets/images/16733443263288-1764bbf249c027947d7c6d39cbf41202.png" width="2342" height="1182" class="img_ev3q">
picture</p><p>SeaTunnel Engine consists of three main services: <strong>CoordinatorService, TaskExecutionService, and SlotService.</strong></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="coordinator-service">Coordinator Service<a href="#coordinator-service" class="hash-link" aria-label="Coordinator Service的直接链接" title="Coordinator Service的直接链接">​</a></h3><p>CoordinatorService is the Master service of the cluster, which provides the generation process of each job from LogicalDag to ExecutionDag, and then to PhysicalDag, and finally creates the JobMaster of the job for scheduling execution and status monitoring of the job. CoordinatorService is mainly composed of 4 large functional modules:</p><ol><li>JobMaster is responsible for the generation process from LogicalDag to ExecutionDag to PhysicalDag of a single job, and is scheduled to run by PipelineBaseScheduler.</li><li>CheckpointCoordinator, responsible for the Checkpoint process control of the job.</li><li>ResourceManager is responsible for the application and management of job resources. It currently supports Standalone mode and will support On Yarn and On K8s in the future.</li><li>Metrics Service, responsible for the statistics and summary of job monitoring information.</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="taskexecutionservice">TaskExecutionService<a href="#taskexecutionservice" class="hash-link" aria-label="TaskExecutionService的直接链接" title="TaskExecutionService的直接链接">​</a></h3><p>TaskExecutionService is the Worker service of the cluster, which provides the real runtime environment of each Task in the job. TaskExecutionService uses Dynamic Thread Sharing technology to reduce CPU usage.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="slotservice">SlotService<a href="#slotservice" class="hash-link" aria-label="SlotService的直接链接" title="SlotService的直接链接">​</a></h3><p>SlotService runs on each node of the cluster and is mainly responsible for the division, application, and recycling of resources on the node.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="04-unique-advantages-and-features">04 Unique advantages and features<a href="#04-unique-advantages-and-features" class="hash-link" aria-label="04 Unique advantages and features的直接链接" title="04 Unique advantages and features的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="autonomous-cluster">Autonomous cluster<a href="#autonomous-cluster" class="hash-link" aria-label="Autonomous cluster的直接链接" title="Autonomous cluster的直接链接">​</a></h3><p>SeaTunnel Engine has realized autonomous clustering (no centralization). To achieve cluster autonomy and job fault tolerance without relying on third-party service components (such as Zookeeper), SeaTunnel Engine uses Hazelcast as the underlying dependency. Hazelcast provides a distributed memory network, allowing users to operate a distributed collection like a normal Java collection locally. SeaTunnel saves the status information of the job in the memory grid of Hazelcast. When the Master node switches, it can Job state recovery based on data in the Hazelcast in-memory grid. At the same time, we have also implemented the persistence of Hazelcast memory grid data, and persisted the job status information to the storage (database of JDBC protocol, HDFS, cloud storage) in the form of WAL. In this way, even if the entire cluster hangs and restarts, the runtime information of the job can be repaired.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="data-cache">Data cache<a href="#data-cache" class="hash-link" aria-label="Data cache的直接链接" title="Data cache的直接链接">​</a></h3><p>SeaTunnel Engine is different from the traditional Spark/Flink computing engine, it is an engine specially used for data synchronization. The SeaTunnel engine naturally supports data cache. When multiple synchronous jobs in the cluster share a data source, the SeaTunnel engine will automatically enable the data cache. The source of a job will read the data and write it into the cache, and all other jobs will no longer read data from the data source but are automatically optimized to read data from the Cache. The advantage of this is that it can reduce the reading pressure of the data source and reduce the impact of data synchronization on the data source.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="speed-control">Speed control<a href="#speed-control" class="hash-link" aria-label="Speed control的直接链接" title="Speed control的直接链接">​</a></h3><p>SeaTunnel Engine supports the speed limit during data synchronization, which is very useful when reading data sources with high concurrency. A reasonable speed limit can not only ensure that the data is synchronized on time, but also minimize the pressure on the data source.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="shared-connection-pool-to-reduce-database-pressure">Shared connection pool to reduce database pressure<a href="#shared-connection-pool-to-reduce-database-pressure" class="hash-link" aria-label="Shared connection pool to reduce database pressure的直接链接" title="Shared connection pool to reduce database pressure的直接链接">​</a></h3><p>At present, the underlying operating tools and data synchronization tools provided by computing engines such as Spark/Flink cannot solve the problem that each table needs a JDBC connection when the entire database is synchronized. Database connections are resources for the database. Too many database connections will put great pressure on the database, resulting in a decrease in the stability of database read and write delays. This is a very serious accident for business databases. To solve this problem, SeaTunnel Engine uses a shared connection pool to ensure that multiple tables can share JDBC connections, thereby reducing the use of database connections.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="breakpoint-resume-incrementalfull-volume">Breakpoint resume (incremental/full volume)<a href="#breakpoint-resume-incrementalfull-volume" class="hash-link" aria-label="Breakpoint resume (incremental/full volume)的直接链接" title="Breakpoint resume (incremental/full volume)的直接链接">​</a></h3><p>SeaTunnel Engine supports resumed uploads under offline synchronization. When the amount of data is large, a data synchronization job often needs to run for tens of minutes or several hours. If the middle job hangs up and reruns, it means wasting time. SeaTunnel Engine will continue to save the state (checkpoint) during the offline synchronization process. When the job hangs up and reruns, it will continue to run from the last checkpoint, which effectively solves the data that may be caused by hardware problems such as node downtime. Delay.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-schema-revolution-route">The Schema revolution route<a href="#the-schema-revolution-route" class="hash-link" aria-label="The Schema revolution route的直接链接" title="The Schema revolution route的直接链接">​</a></h3><p>Schema evolution is a feature that allows users to easily change a table&#x27;s current schema to accommodate data that changes over time. Most commonly, it is used when performing an append or overwrite operation, to automatically adjust the schema to include one or more new columns.</p><p>This capability is required in real-time data warehouse scenarios. Currently, the Flink and Spark engines do not support this feature.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="fine-grained-fault-tolerant-design">Fine-grained fault-tolerant design<a href="#fine-grained-fault-tolerant-design" class="hash-link" aria-label="Fine-grained fault-tolerant design的直接链接" title="Fine-grained fault-tolerant design的直接链接">​</a></h3><p>Flink&#x27;s design is fault tolerance and rollback at the entire job level. If a task fails, the entire job will be rolled back and restarted. The design of SeaTunnel Engine takes into account that in the data synchronization scenario, in many q cases, the failure of a task should only need to focus on fault tolerance for tasks that have upstream and downstream relationships with it. Based on this design principle, SeaTunnel Engine will first generate a logical DAG according to the user-configured job configuration file, then optimize the logical DAG, and finally generate a pipeline (a connected subgraph in a job DAG) to call and execute jobs at the granularity. fault tolerance.</p><p>A typical usage scenario is:</p><p>Use the CDC connector to read data from MySQL&#x27;s binlog and write it to another MySQL. If you use Flink or Spark engine, once the target MySQL cannot write, it will cause the task of CDC to read the binlog to be terminated. If MySQL is set If the expiration time of the log is set, the problem of the target MySQL is solved, but the log of the source MySQL is cleared, which leads to data loss and other problems.</p><p>SeaTunnel Engine will automatically optimize this synchronization task, automatically add the source to the target Cache, and then further optimize this job into two Pipelines, pipeline#1 is responsible for reading data from the CDC and writing it to the SeaTunnel Cache, and pipeline#2 is responsible for reading data from the SeaTunnel Cache Cache reads data and writes to target MySQL. If there is a problem with the target MySQL and cannot be written, the pipeline#2 of this synchronization job will be terminated, and the pipeline#1 will still run normally. This design fundamentally solves the above problems and is more in line with the processing logic of the data synchronization engine.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dynamically-share-threads-to-reduce-resource-usage">Dynamically share threads to reduce resource usage<a href="#dynamically-share-threads-to-reduce-resource-usage" class="hash-link" aria-label="Dynamically share threads to reduce resource usage的直接链接" title="Dynamically share threads to reduce resource usage的直接链接">​</a></h3><p>SeaTunnel Engine&#x27;s Task design uses shared thread technology. Different from Flink/Spark, SeaTunnel Engine does not simply allow a Task to occupy a thread, but through a dynamic perception method - Dynamic Thread Sharing (Dynamic Thread Sharing) To judge whether a Task should share a thread with other Tasks or should monopolize a thread.</p><p>Compared with single-threaded serial computing, multi-threaded parallel computing has better performance advantages, but if each Task uses an independent thread to run, when there are many tables for data synchronization and the number of Tasks is large, it will be in the Worker node Start very many threads on it. When the number of CPU cores is fixed, the more threads, the better. When the number of threads is too large, the CPU needs to spend a lot of time on thread context switching, which will affect computing performance.</p><p>Flink/Spark usually limits the maximum number of tasks running on each node. In this way, it can avoid starting too many threads. To run more tasks on one node, SeaTunnel Engine can share thread technology. Let those tasks with a small amount of data share threads, and tasks with a large amount of data exclusively use threads. This method makes it possible for SeaTunnel Engine to run hundreds or thousands of table synchronization tasks on one node, with less resource occupation. Complete the synchronization of more tables.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="05-basic-functions-and-features">05 Basic functions and features<a href="#05-basic-functions-and-features" class="hash-link" aria-label="05 Basic functions and features的直接链接" title="05 Basic functions and features的直接链接">​</a></h2><p>2.3.0 is the first official version of SeaTunnel Engine, which implements some basic functions. For the detailed design, please refer to: <a href="https://github.com/apache/incubator-seatunnel/issues/2272" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/issues/2272</a></p><p><strong>[ Cluster Management ]</strong></p><ul><li>Support stand-alone operation</li><li>Support cluster operation</li><li>Autonomous cluster (no centralization), no need to specify a Master node for the SeaTunnel Engine cluster, SeaTunnel Engine elects the Master node by itself during operation and automatically selects a new Master node after the Master node hangs up.</li><li>Automatic discovery of cluster nodes, the nodes with the same cluster_name will automatically form a cluster.</li></ul><p><strong>[ Core function ]</strong></p><ul><li>Supports running jobs in Local mode. The cluster is automatically destroyed after the job runs.</li><li>It supports running jobs in Cluster mode (single machine or cluster) and submitting jobs to the SeaTunnel Engine service through SeaTunnel Client. After the job is completed, the service continues to run and waits for the next job submission.</li><li>Support offline batch synchronization.</li><li>Support real-time synchronization.</li><li>Batch and flow integration, all SeaTunnel V2 version connectors can run in SeaTunnel Engine.</li><li>Supports distributed snapshot algorithm cooperates with SeaTunnel V2 connector to support two-phase commit, and ensures data exactly-once.</li><li>Supports job invocation at the Pipeline level to ensure that it can be started even when resources are limited.</li><li>Supports job fault tolerance at the Pipeline level. The failure of a Task only affects the Pipeline it is in, and only the Task under the Pipeline needs to be rolled back.</li><li>Supports dynamic thread sharing to achieve real-time synchronization of a large number of small data sets.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="06-future-optimization-plan">06 Future optimization plan<a href="#06-future-optimization-plan" class="hash-link" aria-label="06 Future optimization plan的直接链接" title="06 Future optimization plan的直接链接">​</a></h2><ul><li>Support Cache mode, and first support Kafka as Cache</li><li>Support JobHistory, support the persistence of JobHistory.</li><li>Support indicator (Reader Rows, QPS, Reader Bytes) monitoring and indicator query</li><li>Support dynamic modification of the execution plan.</li><li>Support CDC.</li><li>Support whole database synchronization</li><li>Support multi-table synchronization</li><li>Support for Schema Revolution</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh-CN/blog/tags/meetup">Meetup</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="Apache IoTDB (Internet of Things Database) is a software system that integrates the collection, storage, management, and analysis of time series data of the Internet of Things, which can meet the needs of massive data storage, high-speed data reading, and complex data analysis in the field of Industrial Internet of Things. Currently, SeaTunnel already supports IoTDB Connector, realizing the connection of data synchronization scenarios in the IoT field."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-CN/blog/Apache IoTDB (Internet of Things Database) is a software system that integrates the collection">SeaTunnel supports IoTDB to implement IoT data synchronization</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-12-10T00:00:00.000Z" itemprop="datePublished">2022年12月10日</time> · <!-- -->阅读需 12 分钟</div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="/zh-CN/assets/images/16714316482580-41ece0a1c0d976185e2c75f3329aa12d.jpg" width="720" height="320" class="img_ev3q"></p><blockquote><p>Apache IoTDB (Internet of Things Database) is a software system that integrates the collection, storage, management, and analysis of time series data of the Internet of Things, which can meet the needs of massive data storage, high-speed data reading, and complex data analysis in the field of Industrial Internet of Things. Currently, SeaTunnel already supports IoTDB Connector, realizing the connection of data synchronization scenarios in the IoT field.</p></blockquote><blockquote><p>At the SeaTunnel community online meeting in October this year, SeaTunnel Committer Wang Hailin introduced the implementation process of SeaTunnel’s access to IoTDB, allowing users to have a deeper understanding of the operation method and principle of IoTDB data synchronization.</p></blockquote><p>The topic I’m sharing today is using SeaTunnel to play around with data synchronization in IoTDB.</p><p>This session is divided into 6 subsections. Firstly, we will have an understanding of the basic concept of SeaTunnel, and on this basis, we will focus on the functional features of IoTDB Connector, then we will analyze the data read and write functions of IoTDB Connector and the parsing of the implementation, and finally, we will show some typical usage scenarios and cases to let you understand how to use Finally, we will show some typical usage scenarios and cases to understand how to use the IoTDB Connector to implement into production environments. The last point is the community’s next steps for the IoTDB Connector and guidance on how to get involved in contributing.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction-to-seatunnel-basic-concepts">Introduction to SeaTunnel basic concepts<a href="#introduction-to-seatunnel-basic-concepts" class="hash-link" aria-label="Introduction to SeaTunnel basic concepts的直接链接" title="Introduction to SeaTunnel basic concepts的直接链接">​</a></h2><p>This is the basic architecture of SeaTunnel, an engine built for data synchronization, with a set of abstract APIs for reading data from and writing to a variety of data sources.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714316839299-a92e73bfbc3881b099146d6d161c412f.jpg" width="720" height="389" class="img_ev3q">
The left-hand side briefly lists the Source scenarios, for example, we abstract the Source’s API, Type, and State, to read the data source, unifying the data types of the various data sources to the abstract type defined in it, and some state recovery and retention of the read location during the reading process.</p><p>This is an abstraction for Source, and we have done a similar abstraction for Sink, i.e. how data is written, and how the data type matches the real data source type, and how the state is restored and retained.</p><p>Based on these APIs, we will have a translation layer to translate these APIs to the corresponding execution engine. SeaTunnel currently supports three execution engines, Spark, Flink, and our own execution engine, SeaTunnel Engine, which will be released soon.</p><p>This is roughly what SeaTunnel does, SeaTunnel relies on Source and Sink to read and write data for data synchronization, we call them Connectors. The Connector consists of a Source and a Sink.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714316928812-337c3d4770094c09ae55a5312670d87f.jpg" width="720" height="758" class="img_ev3q">
From the diagram above we see the different data sources, Source is responsible for reading data from the various data sources and transforming it into SeaTunnelRow abstraction layer and Type to form the abstraction layer, Sink is responsible for pulling data from the abstraction layer and writing it to the concrete data store to transform it into the store concrete format.</p><p>The combination of Source + Abstraction Layer + Sink enables the synchronization of data between multiple heterogeneous data sources.</p><p>I’ll use a simple example below to illustrate how SeaTunnel’s Source and Sink work.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714317022389-f17930bc8877d173d40eab8fdfe47631.jpg" width="720" height="822" class="img_ev3q"></p><p><img loading="lazy" src="/zh-CN/assets/images/16714317067444-f828b5a72003d3caec8958edccdc8dca.jpg" width="720" height="340" class="img_ev3q">
We can specify the number of Sources, Sink configuration file combinations through the configuration file The commands in the toolkit provided by SeaTunnel take the configuration file with them and when executed enable data handling.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714317166018-4c6a20778066aa8bfb5c319c4706b17b.jpg" width="720" height="1202" class="img_ev3q">
<img loading="lazy" src="/zh-CN/assets/images/16714317203806-c4d2fe2e0a1d9a235d59e878c42b9308.jpg" width="651" height="1280" class="img_ev3q">
<img loading="lazy" src="/zh-CN/assets/images/16714317262218-a608b27e7ed69d6bab301f6bdf929966.jpg" width="720" height="933" class="img_ev3q">
This is the Connector ecosystem that is currently supported by SeaTunnel, such as the data sources supported by JBDC, HDFS, Hive, Pulsar, message queues, etc. are currently supported.</p><p>The list in the picture is not exhaustive of the Connectors supported by SeaTunnel. Under the GitHub SeaTunnel project, you can see the Plugins directory, where supported Connector plugins are constantly being added and where you can see the latest access in real-time.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="iotdb-connector-features">IoTDB Connector Features<a href="#iotdb-connector-features" class="hash-link" aria-label="IoTDB Connector Features的直接链接" title="IoTDB Connector Features的直接链接">​</a></h2><p>Below is information about access to the IoTDB Connector.</p><p>Firstly, we would like to introduce the functional features of IoTDB, the IoTDB Connector integrated with SeaTunnel, and what exactly it supports for your reference.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="source-features">Source Features<a href="#source-features" class="hash-link" aria-label="Source Features的直接链接" title="Source Features的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714317512435-d9aa02e6d36efefd2a2c20cf77ce8f6b.jpg" width="720" height="384" class="img_ev3q">
Firstly, there are the typical usage scenarios supported by Source, such as bulk reading of devices, field projection, data type mapping, parallel reading, etc.</p><p>As you can see above, IoTDB supports all features except once, exactly once and stream mode, such as batch reads, IoTDB has a SQL syntax similar to group by device, which allows you to read data from multiple devices in a single batch. For basic data type projection, the SQL in IoTDB will take time by default when looking up any metric, or group by the device will take the device column, and we also support projection onto SeaTunnel columns by default.</p><p>The only data type not supported is Victor, all others are supported.</p><p>For the parallel read piece, the IoTDB data is actually timestamped and we use timestamped ranges to achieve parallel reads.</p><p>The recovery of the state, since we have divided the time range read into different splits, can be done based on the Split location information.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="sink-functional-features">Sink functional features<a href="#sink-functional-features" class="hash-link" aria-label="Sink functional features的直接链接" title="Sink functional features的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714317679569-a1923e70d93e6204c42aa7531a96a024.jpg" width="720" height="372" class="img_ev3q"></p><p>The diagram above shows the features already supported by SeaTunnel. Regarding metadata extraction, we support the extraction of metadata such as measurement, device, etc. from SeaTunnelRow and the extraction or use of current processing time from SeaTunnelRow. Batch commits and exception retries are also supported.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="iotdb-data-reading-analysis">IoTDB data reading analysis<a href="#iotdb-data-reading-analysis" class="hash-link" aria-label="IoTDB data reading analysis的直接链接" title="IoTDB data reading analysis的直接链接">​</a></h2><p>Next, we analyze the implementation and support for data reading.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-type-mapping">Data type mapping<a href="#data-type-mapping" class="hash-link" aria-label="Data type mapping的直接链接" title="Data type mapping的直接链接">​</a></h2><p>The first is the data type mapping, which actually reads the IoTDB data type to SeaTunnel, so it has to be converted to the SeaTunnel data type.
<img loading="lazy" src="/zh-CN/assets/images/16714317930593-3931931989e2fc8224bb071304463c53.jpg" width="720" height="460" class="img_ev3q">
The BOOLEAN, INT32, INT64, etc. listed here all have corresponding SeaTunnel data types. INT32 can be mapped according to the read type on the SeaTunnel, or to TINYINT, SMALLINT, or INT when the range of values is small.</p><p>The Vector type is not currently supported.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714318216373-6472b0b9745b67620ca357054a0715fb.jpg" width="720" height="758" class="img_ev3q">
This is the corresponding example code showing how the mapping is done where the type conversion is done.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="field-projection">Field projection<a href="#field-projection" class="hash-link" aria-label="Field projection的直接链接" title="Field projection的直接链接">​</a></h2><p>The other is the field projection when reading, we can automatically map Time fields when reading IoTDB data, or we can choose to map some of the data to SeaTunnel, such as TIMESTAMP, or BIGINT.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714318381313-29a760765ae69e80e04015976521aabe.jpg" width="720" height="320" class="img_ev3q">
The SQL extraction of column codes allows you to extract only some of the columns you need, and when used on SeaTunnel, you can specify the name, type, etc. of the column after it is mapped to SeaTunnel via fields. The final result of the data read on SeaTunnel is shown in the figure above.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714318550071-25f4bde1d47b33463a1f2d6e13651435.jpg" width="720" height="368" class="img_ev3q"></p><p>We have just seen that we do not have the time column in the SQL, but the actual result is that there is this column, so we support the projection of the time column field, the time column can actually be projected into different data types, the user can convert according to their needs. The diagram above shows the implementation logic.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="batch-read-device">Batch read Device<a href="#batch-read-device" class="hash-link" aria-label="Batch read Device的直接链接" title="Batch read Device的直接链接">​</a></h2><p>This is a common requirement, as we are likely to synchronize data in large batches with the same data structure.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714318796196-bee32b3eae066fdc0ce82182fc6eeb09.jpg" width="720" height="333" class="img_ev3q"></p><p>SeaTunnel supports the align-by-device syntax so that device columns can also be projected onto the SeaTunnelRow</p><p><img loading="lazy" src="/zh-CN/assets/images/16714318873362-54b8d7281a93bc335a39e995db5e1a4f.jpg" width="720" height="185" class="img_ev3q">
Assuming there is a table in IoTDB, we project the device column onto SeaTunnel by making it data as well through syntax. After configuring the device name column and specifying the data type, we end up reading the data on SeaTunnel in the format shown above, containing the Time, device column, and the actual data value. This makes it possible to read data from the same device in bulk.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="parallel-reading">Parallel reading<a href="#parallel-reading" class="hash-link" aria-label="Parallel reading的直接链接" title="Parallel reading的直接链接">​</a></h2><p>The other is a parallel read.</p><ul><li><p>Split
We have scoped the table by the Time column and if we are reading in parallel we may want to scope the table to allow parallel threads/processes to read a specific range of data. By configuring the three parameters, the end result will be a query SQL, where the original SQL is divided into different splits with query conditions to achieve the actual read SQL.</p></li><li><p>Allocate Split to the reader
Once the split is done, there is an allocation logic to follow in order to distribute it to each parallel reader.</p></li></ul><p><img loading="lazy" src="/zh-CN/assets/images/16714319281280-dfc833cfbd8315f969c518271cd38e95.jpg" width="720" height="162" class="img_ev3q"></p><p>This logic is based on the ID of the split to the reader, which may be more random, or more uniform if the ID of the split is more hashed, depending on the Connector.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714319372730-361662ffb0d74adea0f64073bf2cf44f.jpg" width="720" height="528" class="img_ev3q"></p><p>The result achieved is shown in the picture.</p><h1>Status recovery</h1><p>There is also state recovery involved when reading because if the task is large, the reading will take longer, and if there is an error or exception in the middle, you have to consider how to recover the state from the point where the error occurred, and then read it again afterward.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714319281280-dfc833cfbd8315f969c518271cd38e95.jpg" width="720" height="162" class="img_ev3q">
<img loading="lazy" src="/zh-CN/assets/images/16714319569097-2f328036d7363eb6b0d3678984d78af0.jpg" width="720" height="268" class="img_ev3q">
<img loading="lazy" src="/zh-CN/assets/images/16714319599521-13dc977f614b93a4db1eed15ee1e4f30.jpg" width="720" height="256" class="img_ev3q"></p><p>SeaTunnel’s state recovery is mainly through the reader storing the unread Split information into the state, and then the engine will periodically take a snapshot of the state when reading so that we can restore the last snapshot when we recover and continue reading afterward.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="iotdb-connector-data-write-analysis">IoTDB Connector Data Write Analysis<a href="#iotdb-connector-data-write-analysis" class="hash-link" aria-label="IoTDB Connector Data Write Analysis的直接链接" title="IoTDB Connector Data Write Analysis的直接链接">​</a></h2><p>The next step is the parsing of the data writes.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-type-mapping-1">Data type mapping<a href="#data-type-mapping-1" class="hash-link" aria-label="Data type mapping的直接链接" title="Data type mapping的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714319862080-244a507b57e8568444d4ead4b29349aa.jpg" width="720" height="457" class="img_ev3q"></p><p>Data writing also involves data type mapping, but here, in contrast to data reading, it maps the SeaTunnel data types to the IoTDB data types. As IoTDB only has INT32, the writing process involves lifting the data types TINYINT and SMALLINT. All other data types can be converted one-to-one; ARRAY and VECTOR data types are not yet supported.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714319949478-1f6dc7ae103ae0ab3852b1350c74f659.jpg" width="720" height="574" class="img_ev3q"></p><p>The above diagram shows the corresponding code, the implementation logic will need to be seen in our specific mapping.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="dynamic-injection-of-metadata">Dynamic injection of metadata<a href="#dynamic-injection-of-metadata" class="hash-link" aria-label="Dynamic injection of metadata的直接链接" title="Dynamic injection of metadata的直接链接">​</a></h2><p>SeaTunnel supports the dynamic injection of metadata.</p><p>When heterogeneous data sources are written to the IoTDB, device, measurement, and time are extracted from each row of data, either by serializing the SeaTunnelRow with a fixed column value as configured. Alternatively, the system time can be used as the time, or the current system time can be populated if no time column is specified, and the storage group can be configured to be automatically appended to the device prefix.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714320117277-aca2fc93f15601665ef8fd53529953fa.jpg" width="720" height="180" class="img_ev3q"></p><p>For example, suppose that the structure of a row in SeaTunnel reading the data format shown above can be configured to synchronize to the IoTDB and the result obtained is as follows.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714320201848-d017fa8600fc03c9e77914a53c961557.jpg" width="720" height="197" class="img_ev3q"></p><p>The temperature and humidity columns we need were extracted, and ts and device names were extracted as the original data for the IoTDB.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="batch-commits-and-exception-retries">Batch commits and exception retries<a href="#batch-commits-and-exception-retries" class="hash-link" aria-label="Batch commits and exception retries的直接链接" title="Batch commits and exception retries的直接链接">​</a></h2><p>In addition, Sink needs to handle batch and retry when writing. For batches, we can configure the appropriate batch configuration, including support for configuring the number and interval of batch commits; if the data is cached to memory, you can enable a separate thread for timed commits.</p><p>For retries, SeaTunnel supports the configuration of the number of retries, the waiting interval and the maximum number of retries, as well as the possibility to end a retry if it encounters a non-recoverable error when it has finished.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714320394193-27ad106e26762595d5b919019bd72550.jpg" width="720" height="466" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="iotdb-connector-usage-examples">IoTDB Connector Usage Examples<a href="#iotdb-connector-usage-examples" class="hash-link" aria-label="IoTDB Connector Usage Examples的直接链接" title="IoTDB Connector Usage Examples的直接链接">​</a></h2><p>After the previous analysis of reading and writing data, let’s look at three typical examples of usage scenarios.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="exporting-data-from-iotdb">Exporting data from IoTDB<a href="#exporting-data-from-iotdb" class="hash-link" aria-label="Exporting data from IoTDB的直接链接" title="Exporting data from IoTDB的直接链接">​</a></h2><p>The first scenario is exporting data from the IoTDB, the example I have given here is reading data from the IoTDB to the Console.</p><ul><li>Read in parallel, output to Console</li></ul><p>Parallelism: 2</p><p>Number of batches: 24</p><p>Time frame: 2022–09–25 ~ 2022–09–26
<img loading="lazy" src="/zh-CN/assets/images/16714320856052-31c7463162a38c89034e9a14813d4686.jpg" width="720" height="247" class="img_ev3q"></p><p>Let’s assume that we have a data table in IoTDB and we want to export the data to the Console. The whole configuration is shown above and needs to map the columns of data we want to export and the time range to check.</p><p>This is the simplest example, but in practice, the Sink side may be more complex, so you will need to refer to the documentation of the corresponding data source for the appropriate configuration.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="importing-data-to-iotdb">Importing data to IoTDB<a href="#importing-data-to-iotdb" class="hash-link" aria-label="Importing data to IoTDB的直接链接" title="Importing data to IoTDB的直接链接">​</a></h2><ul><li>Read database, batch write to IoTDB<ul><li>Batch writing: one commit every 1024 entries or every 1000 ms</li><li>-Extracting metadata device, timestamp, measurement</li><li>-Specify the storage group: root.test_group</li></ul></li></ul><p><img loading="lazy" src="/zh-CN/assets/images/16714321290339-3c0479957e9a28da554374f5c8d4f426.jpg" width="720" height="284" class="img_ev3q">
Another typical usage scenario is to import data from other data sources into IoTDB. suppose I have an external database table with columns like ts, temperature, humidity, etc. and we import it into IoTDB, requiring the columns of temperature and humidity, but the rest can be left out. The whole configuration is shown in the diagram above, you can refer to it.</p><p>On the Sink side, you mainly have to specify the Key of the device column, such as from which data the device is extracted, from which class the time is extracted, which columns to write to the IoTDB, etc.</p><p>As you can see, we can configure the storage group, which is the storage group of the IoTDB, which can be specified by the storage group.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="synchronizing-data-between-iotdb">Synchronizing data between IoTDB<a href="#synchronizing-data-between-iotdb" class="hash-link" aria-label="Synchronizing data between IoTDB的直接链接" title="Synchronizing data between IoTDB的直接链接">​</a></h2><p>The third scenario is to synchronize data between IoTDB and IoTDB and write to IoTDB in bulk, suppose there is a table in IoTDB that needs to be synchronized to another IoTDB, after synchronization the storage group has changed and the name of the indicator of the data column has also changed, then you can use projection to rewrite the indicator name and use SQL to rewrite the storage group.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714321480992-670f922b9dbe990571115d671159bb22.jpg" width="720" height="309" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-to-get-involved-in-contribution">How to get involved in contribution<a href="#how-to-get-involved-in-contribution" class="hash-link" aria-label="How to get involved in contribution的直接链接" title="How to get involved in contribution的直接链接">​</a></h2><p>Finally, a few words about the next steps for the IoTDB Connector and how you can get involved in improving the Connector and contributing new features that are needed.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="next-steps-for-the-iotdb-connector">Next steps for the IoTDB Connector<a href="#next-steps-for-the-iotdb-connector" class="hash-link" aria-label="Next steps for the IoTDB Connector的直接链接" title="Next steps for the IoTDB Connector的直接链接">​</a></h2><ul><li>Support for reading and writing vector data types</li><li>Support for tsfile reads and writes</li><li>Support for writing tsfile and reloading to IoTDB</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh-CN/blog/tags/meetup">Meetup</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="Apache SeaTunnel Committer | Zongwen Li"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-CN/blog/Apache SeaTunnel Committer | Zongwen Li">SeaTunnel engine, designed for tens-of-billions data integration</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-12-09T00:00:00.000Z" itemprop="datePublished">2022年12月9日</time> · <!-- -->阅读需 10 分钟</div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="/zh-CN/assets/images/16714309876928-859e41ec15f205a23a1b25d8a2b80046.jpg" width="720" height="306" class="img_ev3q">
Apache SeaTunnel Committer | Zongwen Li</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction-to-apache-seatunnel">Introduction to Apache SeaTunnel<a href="#introduction-to-apache-seatunnel" class="hash-link" aria-label="Introduction to Apache SeaTunnel的直接链接" title="Introduction to Apache SeaTunnel的直接链接">​</a></h2><p>Apache SeaTunnel is a very easy-to-use ultra-high-performance distributed data integration platform that supports real-time synchronization of massive data.</p><p>Apache SeaTunnel will try its best to solve the problems that may be encountered in the process of mass data synchronization, such as data loss and duplication, task accumulation and delay, low throughput, etc.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="milestones-of-seatunnel">Milestones of SeaTunnel<a href="#milestones-of-seatunnel" class="hash-link" aria-label="Milestones of SeaTunnel的直接链接" title="Milestones of SeaTunnel的直接链接">​</a></h2><p>SeaTunnel, formerly known as Waterdrop, was open-sourced on GitHub in 2017.</p><p>In October 2021, the Waterdrop community joined the Apache incubator and changed its name to SeaTunnel.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="seatunnel-growth">SeaTunnel Growth<a href="#seatunnel-growth" class="hash-link" aria-label="SeaTunnel Growth的直接链接" title="SeaTunnel Growth的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714310892722-67ccd10c8545d757fc1dab589404be3d.jpg" width="720" height="469" class="img_ev3q">
<img loading="lazy" src="/zh-CN/assets/images/16714310916195-8701b0e12c30eae7063696ec13464375.jpg" width="720" height="378" class="img_ev3q">
<img loading="lazy" src="/zh-CN/assets/images/16714310939883-8df5afa031f552b198757dc4dbe0bf70.jpg" width="720" height="392" class="img_ev3q">
When SeaTunnel entered the Apache incubator, the SeaTunnel community ushered in rapid growth.</p><p>As of now, the SeaTunnel community has a total of 151 contributors, 4314 Stars, and 804 forks.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="pain-points-of-existing-engines">Pain points of Existing engines<a href="#pain-points-of-existing-engines" class="hash-link" aria-label="Pain points of Existing engines的直接链接" title="Pain points of Existing engines的直接链接">​</a></h2><p>There are many pain points faced by the existing computing engines in the field of data integration, and we will talk about this first. The pain points usually lie in three directions:</p><ul><li>The fault tolerance ability of the engine;</li><li>Difficulty in configuration, operation, and maintenance of engine jobs;</li><li>The resource usage of the engine.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="fault-tolerance">fault tolerance<a href="#fault-tolerance" class="hash-link" aria-label="fault tolerance的直接链接" title="fault tolerance的直接链接">​</a></h2><p>Global Failover
<img loading="lazy" alt="Global-failover" src="/zh-CN/assets/images/16714311670656-14b472dd8abdeff2639c1701ed9997f9.jpg" width="720" height="176" class="img_ev3q">
For distributed streaming processing systems, high throughput and low latency are often the most important requirements. At the same time, fault tolerance is also very important in distributed systems. For scenarios that require high correctness, the implementation of exactly once is often very important.</p><p>In a distributed streaming processing system, since the computing power, network, load, etc. of each node are different, the state of each node cannot be directly merged to obtain a true global state. To obtain consistent results, the distributed processing system needs to be resilient to node failure, that is, it can recover to consistent results when it fails.</p><p>Although it is claimed in their official blog that Spark’s Structured Streaming uses the Chandy-Lamport algorithm for Failover processing, it does not disclose more details.</p><p>Flink implemented Checkpoint as a fault-tolerant mechanism based on the above algorithm and published related papers: Lightweight Asynchronous Snapshots for Distributed Dataflows</p><p>In the current industrial implementation, when a job fails, all nodes of the job DAG need to failover, and the whole process will last for a long time, which will cause a lot of upstream data to accumulate.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="loss-of-data">Loss of Data<a href="#loss-of-data" class="hash-link" aria-label="Loss of Data的直接链接" title="Loss of Data的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714312426416-f778eaa67ecf527449353404cf0bf421.jpg" width="720" height="175" class="img_ev3q">
The previous problem will cause a long-time recovery, and the business service may accept a certain degree of data delay.</p><p>In a worse case, a single sink node cannot be recovered for a long time, and the source data has a limited storage time, such as MySQL and Oracle log data, which will lead to data loss.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="configuration-is-cumbersome">Configuration is cumbersome<a href="#configuration-is-cumbersome" class="hash-link" aria-label="Configuration is cumbersome的直接链接" title="Configuration is cumbersome的直接链接">​</a></h2><p>Single table Configuration</p><p><img loading="lazy" src="/zh-CN/assets/images/16714312637015-abff06af8bf814cbb39e2fddfd5b0271.jpg" width="720" height="360" class="img_ev3q">
The previous examples are cases regarding a small number of tables, but in real business service development, we usually need to synchronize thousands of tables, which may be divided into databases and tables at the same time;</p><p>The status quo is that we need to configure each table, a large number of table synchronization takes a lot of time for users, and it is prone to problems such as field mapping errors, which are difficult to maintain.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="not-supporting-schema-evolution">Not supporting Schema Evolution<a href="#not-supporting-schema-evolution" class="hash-link" aria-label="Not supporting Schema Evolution的直接链接" title="Not supporting Schema Evolution的直接链接">​</a></h2><p><img loading="lazy" alt="Not-supports-DDL" src="/zh-CN/assets/images/16714312769761-80425f8f27f3efc3ab62487814dad59e.jpg" width="720" height="360" class="img_ev3q">
Besides, according to the research report of Fivetran, 60% of the company’s schema will change every month, and 30% will change every week.</p><p>However, none of the existing engines supports Schema Evolution. After changing the Schema each time, the user needs to reconfigure the entire link, which makes the maintenance of the job very cumbersome.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-high-volume-of-resource-usage">The high volume of resource usage<a href="#the-high-volume-of-resource-usage" class="hash-link" aria-label="The high volume of resource usage的直接链接" title="The high volume of resource usage的直接链接">​</a></h2><p>The database link takes up too much</p><p><img loading="lazy" src="/zh-CN/assets/images/16714313100541-98837b408ddcd3e5d7114421e893de80.jpg" width="720" height="480" class="img_ev3q">
If our Source or Sink is of JDBC type, since the existing engine only supports one or more links per table, when there are many tables to be synchronized, more link resources will be occupied, which will bring a great burden to the database server.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="operator-pressure-is-uncontrollable">Operator pressure is uncontrollable<a href="#operator-pressure-is-uncontrollable" class="hash-link" aria-label="Operator pressure is uncontrollable的直接链接" title="Operator pressure is uncontrollable的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714313301435-5d797838b956772428477a7a26a2591c.jpg" width="720" height="333" class="img_ev3q">
In the existing engine, a buffer and other control operators are used to control the pressure, that is, the back pressure mechanism; since the back pressure is transmitted level by level, there will be pressure delay, and at the same time, the processing of data will not be smooth enough, increasing the GC time, fault-tolerant completion time, etc.</p><p>Another case is that neither the source nor the sink has reached the maximum pressure, but the user still needs to control the synchronization rate to prevent too much impact on the source database or the target database, which cannot be controlled through the back pressure mechanism.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="architecture-goals-of-apache-seatunnel-engine">Architecture goals of Apache SeaTunnel Engine<a href="#architecture-goals-of-apache-seatunnel-engine" class="hash-link" aria-label="Architecture goals of Apache SeaTunnel Engine的直接链接" title="Architecture goals of Apache SeaTunnel Engine的直接链接">​</a></h2><p>To solve these severe issues faced by computing engines, we self-developed our engine expertise in big data integration.</p><p>Firstly, let’s get through what goals this engine wants to achieve.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="pipeline-failover">Pipeline Failover<a href="#pipeline-failover" class="hash-link" aria-label="Pipeline Failover的直接链接" title="Pipeline Failover的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714313559400-d6029daeb8672d49a5bfb8718c518e3f.jpg" width="720" height="176" class="img_ev3q">
In the data integration case, there is a possibility that a job can synchronize hundreds of sheets, and the failure of one node or one table will lead to the failure of all tables, which is too costly.</p><p>We expect that unrelated Job Tasks will not affect each other during fault tolerance, so we call a vertex collection with upstream and downstream relationships a Pipeline, and a Job can consist of one or more pipelines.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="regional-failover">Regional Failover<a href="#regional-failover" class="hash-link" aria-label="Regional Failover的直接链接" title="Regional Failover的直接链接">​</a></h2><p>Now if there is an exception in the pipeline, we still need to failover all the vertex in the pipeline; but can we restore only part of the vertex?
<img loading="lazy" src="/zh-CN/assets/images/16714313919617-100427ea7efcebd349ce998e13a8c0a0.jpg" width="720" height="176" class="img_ev3q">
For example, if the Source fails, the Sink does not need to restart. In the case of a single Source and multiple Sinks, if a single Sink fails, only the Sink and Source that failed will be restored; that is, only the node that failed and its upstream nodes will be restored.</p><p>Obviously, the stateless vertex does not need to be restarted, and since SeaTunnel is a data integration framework, we do not have aggregation state vertexes such as Agg and Count, so we only need to consider Sink;</p><ul><li>Sink does not support idempotence &amp; 2PC; no restart and restart will result in the same data duplication, which can only be solved by Sink without restarting;</li><li>Sink supports idempotence, but does not support 2PC: because it is idempotent writing, it does not matter whether the source reads data inconsistently every time, and it does not need to be restarted;</li><li>Sink supports 2PC:</li><li>If the Source supports data consistency, if an abort is not executed, the processed old data will be automatically ignored through the channel data ID, and at the same time, it will face the problem that the transaction session time may time out;</li><li>If the Source does not support data consistency, perform abort on the Sink to discard the last data, which has the same effect as restarting but does not require initialization operations such as re-establishing links;</li><li>That is, the simplest implementation is to execute abort.
We use the pipeline as the minimum granularity for fault-tolerant management, and use the Chandy-Lamport algorithm to realize fault-tolerant distributed jobs.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-cache">Data Cache<a href="#data-cache" class="hash-link" aria-label="Data Cache的直接链接" title="Data Cache的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714314318184-95b8b08ab40b5d0da4ca1bd2e659f965.jpg" width="720" height="175" class="img_ev3q">
For sink failure, when data cannot be written, a possible solution is to work two jobs at the same time.</p><p>One job reads the database logs using the CDC source connector and then writes the data to Kafka using the Kafka Sink connector. Another job reads data from Kafka using the Kafka source connector and writes data to the destination using the destination sink connector.</p><p>This solution requires users to have a deep understanding of the underlying technology, and both tasks will increase the difficulty of operation and maintenance. Because every job needs JobMaster, it requires more resources.</p><p>Ideally, the user only knows that they will be reading data from the source and writing data to the sink, and at the same time, during this process, the data can be cached in case the sink fails. The sync engine needs to automatically add caching operations to the execution plan and ensure that the source still works in the event of a sink failure. In this process, the engine needs to ensure that the data written to the cache and read from the cache are transactional, to ensure data consistency.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="sharding--multi-table-sync">Sharding &amp; Multi-table Sync<a href="#sharding--multi-table-sync" class="hash-link" aria-label="Sharding &amp; Multi-table Sync的直接链接" title="Sharding &amp; Multi-table Sync的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714314489916-cd0b185b6626a8c1598aa3ac569ecdbd.jpg" width="720" height="448" class="img_ev3q"></p><p>For a large number of table synchronization, we expect that a single Source can support reading multiple structural tables, and then use the side stream output to keep consistent with a single table stream.</p><p>The advantage of this is that it can reduce the link occupation of the data source and improve the utilization rate of thread resources.</p><p>At the same time, in SeaTunnel Engine, these multiple tables will be regarded as a pipeline, which will increase the granularity of fault tolerance; there are trade-offs, and the user can choose how many tables a pipeline can pass through.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="schema-evolution">Schema Evolution<a href="#schema-evolution" class="hash-link" aria-label="Schema Evolution的直接链接" title="Schema Evolution的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714314658701-b97c66b4a4eacfe54acf2e5ea6cc001b.jpg" width="720" height="199" class="img_ev3q">
Schema Evolution is a feature that allows users to easily change the current schema of a table to accommodate changing data over time. Most commonly, it is used when performing an append or overwrite operation, to automatically adjust the schema to include one or more new columns.</p><p>This feature is required for real-time data warehouse scenarios. Currently, the Flink and Spark engines do not support this feature.</p><p>In SeaTunnel Engine, we will use the Chandy-Lamport algorithm to send DDL events, make them flow in the DAG graph and change the structure of each operator, and then synchronize them to the Sink.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="shared-resource">Shared Resource<a href="#shared-resource" class="hash-link" aria-label="Shared Resource的直接链接" title="Shared Resource的直接链接">​</a></h2><p><img loading="lazy" alt="Shared-resource" src="/zh-CN/assets/images/16714314806989-3f0543f4a2b9412e0d6c48eb1b7aa5c1.jpg" width="720" height="455" class="img_ev3q">
The Multi-table feature can reduce the use of some Source and Sink link resources. At the same time, we have implemented Dynamic Thread Resource Sharing in SeaTunnel Engine, reducing the resource usage of the engine on the server.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="speed-control">Speed Control<a href="#speed-control" class="hash-link" aria-label="Speed Control的直接链接" title="Speed Control的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714315001348-d6e97c70a71c7f4b9220a68751cb1401.jpg" width="720" height="323" class="img_ev3q">
As for the problems that cannot be solved by the back pressure mechanism, we will optimize the Buffer and Checkpoint mechanism:</p><ul><li>Firstly, We try to allow Buffer to control the amount of data in a period;</li><li>Secondly, by the Checkpoint mechanism, the engine can lock the buffer after the Checkpoint reaches the maximum number of parallelism and executes an interval time, prohibiting the writing of Source data, achieving the result of taking the pressure proactively, avoiding issues like back pressure delay or failure to be delivered to Source.
The above is the design goal of SeaTunnel Engine, hoping to help you better solve the problems that bother you in data integration. In the future, we will continue to optimize the experience of using SeaTunnel so that more people are willing to use it.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-future-of-apache-seatunnel">The future of Apache SeaTunnel<a href="#the-future-of-apache-seatunnel" class="hash-link" aria-label="The future of Apache SeaTunnel的直接链接" title="The future of Apache SeaTunnel的直接链接">​</a></h2><p>As an Apache incubator project, the Apache SeaTunnel community is developing rapidly. In the following community planning, we will focus on four directions:</p><p>Support more data integration scenarios (Apache SeaTunnel Engine)
It is used to solve the pain points that existing engines cannot solve, such as the synchronization of the entire database, the synchronization of table structure changes, and the large granularity of task failure;</p><blockquote><p>Guys who are interested in the engine can pay attention to this Umbrella: <a href="https://github.com/apache/incubator-seatunnel/issues/2272" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/issues/2272</a></p></blockquote><p>Expand and improve Connector &amp; Catalog ecology
Support more Connector &amp; Catalog, such as TiDB, Doris, Stripe, etc., and improve existing connectors, improve their usability and performance, etc.;
Support CDC connector for real-time incremental synchronization scenarios.</p><blockquote><p>Guys who are interested in connectors can pay attention to this Umbrella: <a href="https://github.com/apache/incubator-seatunnel/issues/1946" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/issues/1946</a></p></blockquote><p>Support for more versions of the engines
Such as Spark 3.x, Flink 1.14.x, etc.</p><blockquote><p>Guys who are interested in supporting Spark 3.3 can pay attention to this PR: <a href="https://github.com/apache/incubator-seatunnel/pull/2574" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel/pull/2574</a></p></blockquote><p>Easier to use (Apache SeaTunnel Web)
Provides a web interface to make operations more efficient in the form of DAG/SQL Simple and more intuitive display of Catalog, Connector, Job, etc.;
Access to the scheduling platform to make task management easier</p><blockquote><p>Guys who are interested in Web can pay attention to our Web sub-project: <a href="https://github.com/apache/incubator-seatunnel-web" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel-web</a></p></blockquote></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh-CN/blog/tags/meetup">Meetup</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="Bo Bi, data engineer at Mafengwo"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-CN/blog/During the joint Apache SeaTunnel &amp; IoTDB Meetup on October 15,">Mafengwo finally chose Apache SeaTunnel after analyzing these 9 points of how it works!</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-11-17T00:00:00.000Z" itemprop="datePublished">2022年11月17日</time> · <!-- -->阅读需 19 分钟</div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="/zh-CN/assets/images/16714322908857-c6ce9a962f477d13b5480206b583b6d2.jpg" width="720" height="480" class="img_ev3q"></p><p><img loading="lazy" src="/zh-CN/assets/images/16714322944041-351d2ac6aa565d636c97a1ad6b0c136e.jpg" width="360" height="309" class="img_ev3q">
Bo Bi, data engineer at Mafengwo</p><blockquote><p>During the joint Apache SeaTunnel &amp; IoTDB Meetup on October 15, Bo Bi, the data engineer at a leading Chinese travel-social e-commerce platform Mafengwo, introduced the basic principles of SeaTunnel and related enterprise practice thinking, the pain points and optimization thinking in typical scenarios of Mafengwo’s big data development and scheduling platform, and shared his experience of participating in community contributions. We hope to help you understand SeaTunnel and the paths and skills of community building at the same time.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction-to-the-technical-principle-of-seatunnel">Introduction to the technical principle of SeaTunnel<a href="#introduction-to-the-technical-principle-of-seatunnel" class="hash-link" aria-label="Introduction to the technical principle of SeaTunnel的直接链接" title="Introduction to the technical principle of SeaTunnel的直接链接">​</a></h2><p>SeaTunnel is a distributed, high-performance data integration platform for the synchronization and transformation of large volumes of data (offline and real-time)</p><p>The diagram above shows the workflow of SeaTunnel, which in simple terms consists of 3 parts: input, transformation, and output; more complex data processing is just a combination of several actions.</p><p>In a synchronization scenario, such as importing Kafka to Elasticsearch, Kafka is the Source of the process and Elasticsearch is the Sink of the process.</p><p>If, during the import process, the field columns do not match the external data columns to be written and some column or type conversion is required, or if you need to join multiple data sources and then do some data widening, field expansion, etc., then you need to add some Transform in the process, corresponding to the middle part of the picture.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714323322988-74b7a47d1a3299efd23c6375d3acaa5e.jpg" width="660" height="781" class="img_ev3q">
This shows that the core of SeaTunnel is the Source, Transform and Sink process definitions.</p><p>In Source we can define the data sources we need to read, in Sink, we can define the data pipeline and eventually write the external storage, and we can transform the data in between, either using SQL or custom functions.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="seatunnel-connector-api-version-v1-architecture-breakdown">SeaTunnel Connector API Version V1 Architecture Breakdown<a href="#seatunnel-connector-api-version-v1-architecture-breakdown" class="hash-link" aria-label="SeaTunnel Connector API Version V1 Architecture Breakdown的直接链接" title="SeaTunnel Connector API Version V1 Architecture Breakdown的直接链接">​</a></h2><p>For a mature component framework, there must be something unique about the design pattern of the API design implementation that makes the framework scalable.</p><p>The SeaTunnel architecture consists of three main parts.</p><p>1、SeaTunnel Basic API.</p><ol><li><p>the implementation of the SeaTunnel base API.</p></li><li><p>SeaTunnel’s plug-in system.</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="seatunnel-basic-api">SeaTunnel Basic API<a href="#seatunnel-basic-api" class="hash-link" aria-label="SeaTunnel Basic API的直接链接" title="SeaTunnel Basic API的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714323668557-9c9260e0c54017b5282b1294ccc9c692.jpg" width="720" height="194" class="img_ev3q">
The above diagram shows the definition of the interface, the Plugin interface in SeaTunnel abstracts the various actions of data processing into a Plugin.</p><p>The five parts of the diagram below, Basesource, Basetransfform, Basesink, Runtimeenv, and Execution, all inherit from the Plugin interface.
<img loading="lazy" src="/zh-CN/assets/images/16714323741126-a61ed7b20a44b14b78d39c7ffe42ec41.jpg" width="720" height="229" class="img_ev3q"></p><p>As a process definition plug-in, Source is responsible for reading data, Transform is responsible for transforming, Sink is responsible for writing and Runtimeenv is setting the base environment variables.</p><p>The overall SeaTunnel base API is shown below</p><p><img loading="lazy" src="/zh-CN/assets/images/16714323846302-eabb8409469fa34d9b0ebd2402fca23d.jpg" width="720" height="347" class="img_ev3q">
Execution, the data flow builder used to build the entire data flow based on the first three, is also part of the base API</p><p><img loading="lazy" src="/zh-CN/assets/images/16714323920717-b5bb28d92939847f1f30c61b6895191a.jpg" width="720" height="192" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="seatunnel-base-api-implementation">SeaTunnel Base API Implementation<a href="#seatunnel-base-api-implementation" class="hash-link" aria-label="SeaTunnel Base API Implementation的直接链接" title="SeaTunnel Base API Implementation的直接链接">​</a></h2><p>Based on the previous basic APIs, SeaTunnel has been implemented in separate packages for different computing engines, currently the Spark API abstraction and the Flink API abstraction, which logically completes the process of building the data pipeline.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714323741126-a61ed7b20a44b14b78d39c7ffe42ec41.jpg" width="720" height="229" class="img_ev3q"></p><p>Due to space constraints, we will focus on Spark batch processing. Based on the wrapped implementation of the previous base Api, the first is that Base spark source implements Base source, base Spark transform implements Base transform and Base Spark sink implements Base sink.</p><p>The method definition uses Spark’s Dataset as the carrier of the data, and all data processing is based on the Dataset, including reading, processing and exporting.</p><p>The SparkEnvironment, which internally encapsulates Spark’s Sparksession in an Env, makes it easy for individual plugins to use.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714324136843-44e65c36b7ef55c34b50a9eb0e43c3cc.jpg" width="720" height="350" class="img_ev3q"></p><p>The Spark batch process ends with SparkBatchExecution (the data stream builder), which is the core code snippet used to functionally build our data stream Pipeline, the most basic data stream on the left in the diagram below.</p><p>The user-based definition of each process component is also the configuration of Source Sink, Transform. More complex data flow logic can be implemented, such as multi-source Join, multi-pipeline processing, etc., all of which can be built through Execution.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714324237449-e5a12e608045d5a153853c93eb844852.jpg" width="720" height="405" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="seatunnel-connector-v1-api-architecture-summary">SeaTunnel Connector V1 API Architecture Summary<a href="#seatunnel-connector-v1-api-architecture-summary" class="hash-link" aria-label="SeaTunnel Connector V1 API Architecture Summary的直接链接" title="SeaTunnel Connector V1 API Architecture Summary的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714324336701-6e5cadce0d1a1858d7bffbf96c5cae82.jpg" width="720" height="405" class="img_ev3q">
SeaTunnel’s API consists of three main parts.</p><p>The first part is the SeaTunnel base API, which provides the basic abstract interfaces such as Source, Sink, Transform, and Plugin.</p><p>The second part is based on a set of interfaces Transform, Sink, Source, Runtime, and Execution provided by the SeaTunnel base API, which is wrapped and implemented on the Flink and Spark engines respectively, i.e. Spark engine API layer abstraction and Flink engine API layer abstraction.</p><p>Both Flink and Spark engines support stream and batch processing, so there are different ways to use streams/batches under the Flink API abstraction and Spark abstraction APIs, such as Flinkstream and Flinkbatch under the Flink abstraction API, and Sparkbatch and Sparkstreaming under the Spark abstraction API.</p><p>The third part is the plug-in system, based on Spark abstraction and Flink API abstraction, SeaTunnel engine implements rich connectors and processing plug-ins, while developers can also be based on different engine API abstractions, and extensions to achieve their own Plugin.</p><p>SeaTunnel Implementation Principle
Currently, SeaTunnel offers a variety of ways to use Flink, Spark, and FlinkSQL. Due to space limitations, we will introduce the execution principles of the Spark method.</p><p>First, the entry starts the command Start-seatunnel-spark.sh via the shell, which internally calls Sparkstarter’s Class, which parses the parameters passed by the shell script, and also parses the Config file to determine which Connectors are defined in the Config file, such as Fake, Console, etc.
<img loading="lazy" src="/zh-CN/assets/images/16714324454477-200fd76badcfc17bdd291f364c70a191.jpg" width="720" height="405" class="img_ev3q">
Then find the Connector path from the Connector plugin directory and stitch it into the Spark-submit launch command with — jar, so that the found Plugin jar package can be passed to the Spark cluster as a dependency.</p><p>For Connector plugins, all Spark Connectors are packaged in the plugin directory of the distribution (this directory is managed centrally).</p><p>After Spark-submit is executed, the task is submitted to the Spark cluster, and the Main class of the Spark job’s Driver builds the data flow Pipeline through the data flow builder Execution, combined with Souce, Sink, and Transform so that the whole chain is connected.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="seatunnel-connector-v2-api-architecture">SeaTunnel Connector V2 API Architecture<a href="#seatunnel-connector-v2-api-architecture" class="hash-link" aria-label="SeaTunnel Connector V2 API Architecture的直接链接" title="SeaTunnel Connector V2 API Architecture的直接链接">​</a></h2><p>In the latest community release of SeaTunnel 2.2.0-beta, the refactoring of the Connectorapi, now known as the SeaTurnelV2 API, has been completed!</p><p>Why do we need to reconfigure?</p><p>As the Container is currently a strongly coupled engine, i.e. Flink and Spark API, if the Flink or Spark engine is upgraded, the Connector will also have to be adjusted, possibly with changes to parameters or interfaces.</p><p>This can lead to multiple implementations for different engines and inconsistent parameters to develop a new Connector. Therefore, the community has designed and implemented the V2 version of the API based on these pain points.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714324726276-11d9d5c6d4e848796fa71329819caa72.jpg" width="720" height="405" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="seatunnel-v2-api-architecture">SeaTunnel V2 API Architecture<a href="#seatunnel-v2-api-architecture" class="hash-link" aria-label="SeaTunnel V2 API Architecture的直接链接" title="SeaTunnel V2 API Architecture的直接链接">​</a></h2><p>SeaTunnel V2 API Architecture</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1table-api">1.Table API<a href="#1table-api" class="hash-link" aria-label="1.Table API的直接链接" title="1.Table API的直接链接">​</a></h3><p>·DataType: defines SeaTunnel’s data structure SeaTunnelRow, which is used to isolate the engine</p><p>·Catalog: used to obtain Table Scheme, Options, etc..</p><p>·Catalog Storage: used to store user-defined Table Schemes etc. for unstructured engines such as Kafka.</p><p>·Table SPI: mainly used to expose the Source and Sink interfaces as an SPI</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-source--sink-api">2. Source &amp; Sink API<a href="#2-source--sink-api" class="hash-link" aria-label="2. Source &amp; Sink API的直接链接" title="2. Source &amp; Sink API的直接链接">​</a></h3><p>Define the Connector’s core programming interface for implementing the Connector</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3engine-api">3.Engine API<a href="#3engine-api" class="hash-link" aria-label="3.Engine API的直接链接" title="3.Engine API的直接链接">​</a></h3><p>·Translation: The translation layer, which translates the Source and Sink APIs implemented by the Connector into a runnable API inside the engine.</p><p>·Execution: Execution logic, used to define the execution logic of Source, Transform, Sink and other operations within the engine.</p><p>The Source &amp; Sink API is the basis for the implementation of the connector and is very important for developers.</p><p>The design of the v2 Source &amp; Sink API is highlighted below</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="seatunnel-connector-v2-source-api">SeaTunnel Connector V2 Source API<a href="#seatunnel-connector-v2-source-api" class="hash-link" aria-label="SeaTunnel Connector V2 Source API的直接链接" title="SeaTunnel Connector V2 Source API的直接链接">​</a></h2><p>The current version of SeaTunnel’s API design draws on some of Flink’s design concepts, and the more core classes of the Source API are shown below.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714325444078-fbed659c615c445655896b93a093177f.jpg" width="720" height="405" class="img_ev3q">
<img loading="lazy" src="/zh-CN/assets/images/16714325474972-48cbee3672ad2f32317d48263f204978.jpg" width="720" height="405" class="img_ev3q">
The core Source API interaction flow is shown above. In the case of concurrent reads, the enumerator SourceSplitEnumerator is required to split the task and send the SourceSplit down to the SourceReader, which receives the split and uses it to read the external data source.</p><p>In order to support breakpoints and Eos semantics, it is necessary to preserve and restore the state, for example by preserving the current Reader’s Split consumption state and restoring it after a failure in each Reader through the Checkpoint state and Checkpoint mechanism, so that the data can be read from the place where it failed.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="seatunnel-connector-v2-sink-api">SeaTunnel Connector V2 Sink API<a href="#seatunnel-connector-v2-sink-api" class="hash-link" aria-label="SeaTunnel Connector V2 Sink API的直接链接" title="SeaTunnel Connector V2 Sink API的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714325600316-f066630b909ec30a7727b7877a4838b0.jpg" width="720" height="405" class="img_ev3q">
The overall Sink API interaction flow is shown in the diagram below. The SeaTunnel sink is currently designed to support distributed transactions, based on a two-stage transaction commit.</p><p>First SinkWriter continuously writes data to an external data source, then when the engine does a checkpoint, it triggers a first-stage commit.</p><p>SinkWriter needs to do a Prepare commit, which is the first stage of the commit.</p><p>The engine will determine if all the Writer&#x27;s first stage succeeds, and if they all succeed, the engine will combine the Subtask’s Commit info with the Commit method of the Committer to do the actual commit of the transaction and operate the database for the Commit, i.e. the second stage of the commit. This is the second stage of commit.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714325681738-973c53bd86223df4ee98cbb2ecb30eaf.jpg" width="570" height="814" class="img_ev3q">
For the Kafka sink connector implementation, the first stage is to do a pre-commit by calling KafkaProducerSender.prepareCommit().</p><p>The second commit is performed via Producer.commitTransaction();.</p><p>flush(); flushes the data from the Broker’s system cache to disk.</p><p>Finally, it is worth noting!</p><p>Both SinkCommitter and SinkAggregatedCommitter can perform a second stage commit to replace the Committer in the diagram. The difference is that SinkCommitter can only do a partial commit of a single Subtask’s CommitInfo, which may be partially successful and partially unsuccessful, and cannot be handled globally. The difference is that the SinkCommitter can only do partial commits of a single Subtask’s CommitInfo, which may be partially successful and partially unsuccessful.</p><p>SinkAggregatedCommitter is a single parallel, aggregating the CommitInfo of all Subtask, and can do the second stage commit as a whole, either all succeed or all fail, avoiding the problem of inconsistent status due to partial failure of the second stage.</p><p>It is therefore recommended that the SinkAggregatedCommitter be used in preference.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="comparison-of-seatunnel-v1-and-v2-api-processing-flows">Comparison of SeaTunnel V1 and V2 API processing flows<a href="#comparison-of-seatunnel-v1-and-v2-api-processing-flows" class="hash-link" aria-label="Comparison of SeaTunnel V1 and V2 API processing flows的直接链接" title="Comparison of SeaTunnel V1 and V2 API processing flows的直接链接">​</a></h2><p>We can look at the changes before and after the V1 V2 upgrade from a data processing perspective, which is more intuitive, Spark batch processing as an example: SeaTunnel V1: The entire data processing process is based on the Spark dataset API, and the Connector and the compute engine are strongly coupled.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714325887598-d27009789ff28e56c8bfcca29bcedfe1.jpg" width="720" height="405" class="img_ev3q">
SeaTunnel V2: Thanks to the work of the engine translator, the Connector API, and the SeaTunnelRow, the data source of the SeaTunnel internal data structures accessed through the Connector, are translated by the translation layer into a runnable Spark API and spark dataset that is recognized inside the engine during data transformation.</p><p>As data is written out, the Spark API and Spark dataset are translated through the translation layer into an executable connector API inside the SeaTunnel connector and a data source of internal SeaTunnel structures that can be used.</p><blockquote><p>Overall, the addition of a translation layer at the API and compute engine layers decouples the Connector API from the engine, and the Connector implementation no longer depends on the compute engine, making the extension and implementation more flexible.</p></blockquote><blockquote><p>In terms of community planning, the V2 API will be the main focus of development, and more features will be supported in V2, while V1 will be stabilized and no longer maintained.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="practice-and-reflections-on-our-off-line-development-scheduling-platform">Practice and reflections on our off-line development scheduling platform<a href="#practice-and-reflections-on-our-off-line-development-scheduling-platform" class="hash-link" aria-label="Practice and reflections on our off-line development scheduling platform的直接链接" title="Practice and reflections on our off-line development scheduling platform的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="practice-and-reflections-on-our-off-line-development-scheduling-platform-1">Practice and reflections on our off-line development scheduling platform<a href="#practice-and-reflections-on-our-off-line-development-scheduling-platform-1" class="hash-link" aria-label="Practice and reflections on our off-line development scheduling platform的直接链接" title="Practice and reflections on our off-line development scheduling platform的直接链接">​</a></h3><p><img loading="lazy" src="/zh-CN/assets/images/16714326227360-bcd55d2c5b7b23ec91a5d1e27c04fb0e.jpg" width="720" height="405" class="img_ev3q">
Hornet’s Nest Big Data Development Platform, which focuses on providing one-stop big data development and scheduling services, helps businesses solve complex problems such as data development management, task scheduling and task monitoring in offline scenarios.</p><p>The offline development and scheduling platform plays the role of the top and the bottom. The top is to provide open interface API and UI to connect with various data application platforms and businesses, and the bottom is to drive various computations and storage, and then run in an orderly manner according to the task dependency and scheduling time.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="platform-capabilities">Platform Capabilities<a href="#platform-capabilities" class="hash-link" aria-label="Platform Capabilities的直接链接" title="Platform Capabilities的直接链接">​</a></h2><p><strong>Data development</strong></p><p>Task configuration, quality testing, release live</p><p><strong>·Data synchronisation</strong></p><p>Data access, data processing, data distribution</p><p><strong>·Scheduling capabilities</strong></p><p>Supports timed scheduling, triggered scheduling</p><p><strong>·Operations and Maintenance Centre
</strong>
Job Diagnosis, Task O&amp;M, Instance O&amp;M</p><p><strong>·Management</strong></p><p>Library table management, permission management, API management, script management</p><p>In summary, the core capabilities of the offline development scheduling platform are openness, versatility, and one-stop shopping. Through standardized processes, the entire task development cycle is managed and a one-stop service experience is provided.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-architecture-of-the-platform">The architecture of the platform<a href="#the-architecture-of-the-platform" class="hash-link" aria-label="The architecture of the platform的直接链接" title="The architecture of the platform的直接链接">​</a></h2><p><img loading="lazy" src="/zh-CN/assets/images/16714326749427-2957d8414a3175ed8cc46bde32a08565.jpg" width="720" height="405" class="img_ev3q">
The Hornet’s Nest Big Data Development and Scheduling Platform consists of four main modules: the task component layer, the scheduling layer, the service layer, and the monitoring layer.</p><p>The service layer is mainly responsible for job lifecycle management (e.g. job creation, testing, release, offline); Airflow dagphthon file building and generating, task bloodline dependency management, permission management, API (providing data readiness, querying of task execution status).</p><p>The scheduling layer is based on Airflow and is responsible for the scheduling of all offline tasks.</p><p>A task component layer that enables users to develop data through supported components that include tools such as SparkSQL/, HiveSQ, LMR), StarRocks import, etc., directly interfacing with underlying HDFS, MySQL, and other storage systems.</p><p>The monitoring layer is responsible for all aspects of monitoring and alerting on scheduling resources, computing resources, task execution, etc.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="open-data-sync-capability-scenarios">Open Data Sync Capability Scenarios<a href="#open-data-sync-capability-scenarios" class="hash-link" aria-label="Open Data Sync Capability Scenarios的直接链接" title="Open Data Sync Capability Scenarios的直接链接">​</a></h2><p>Challenges with open capabilities: Need to support multiple business scenarios and meet flexible data pipeline requirements (i.e. extend to support more task components such as hive2clickhourse, clickhourse2mysql, etc.)</p><p>Extending task components based on Airflow: higher maintenance costs for extensions, need to reduce costs and increase efficiency (based on the limited provider&#x27;s Airflow offers, less applicable in terms of usage requirements, Airflow is a Python technology stack, while our team is mainly based on the Java technology stack, so the technology stack difference brings higher iteration costs)</p><p>Self-developed task components: the high cost of platform integration, long development cycle, high cost of the configuration of task components. (Research or implement task components by yourself, different ways of adapting the parameters of the components in the service layer, no uniform way of parameter configuration)</p><p>We wanted to investigate a data integration tool that, firstly, supported a rich set of components, provided out-of-the-box capabilities, was easy to extend, and offered a uniform configuration of parameters and a uniform way of using them to facilitate platform integration and maintenance.</p><ul><li>Selection of data integration tools
<img loading="lazy" src="/zh-CN/assets/images/16714327002726-6bfd742beb9534e7fdbd917db5f53d51.jpg" width="720" height="405" class="img_ev3q">
To address the pain points mentioned above, we actively explored solutions and conducted a selection analysis of several mainstream data integration products in the industry. As you can see from the comparison above, Datax and SeaTunnel both offer good scalability, and high stability, support rich connector plugins, provide scripted, uniformly configurable usage, and have active communities.</li></ul><p>However, Datax is limited by being distributed and is not well suited to massive data scenarios.</p><p>In contrast, SeaTunnel offers the ability to provide distributed execution, distributed transactions, scalable levels of data handling, and the ability to provide a unified technical solution in data synchronization scenarios.</p><p>In addition to the advantages and features described above and the applicable scenarios, more importantly, the current offline computing resources for big data are unified and managed by yarn, and for the subsequently extended tasks we also wish to execute on Yarn, we finally prefer SeaTunnel for our usage scenarios.</p><p>Further performance testing of SeaTunnel and the development of an open data scheduling platform to integrate SeaTunnel may be carried out at a later stage, and its use will be rolled out gradually.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="outbound-scenario-hive-data-sync-to-starrocks">Outbound scenario: Hive data sync to StarRocks<a href="#outbound-scenario-hive-data-sync-to-starrocks" class="hash-link" aria-label="Outbound scenario: Hive data sync to StarRocks的直接链接" title="Outbound scenario: Hive data sync to StarRocks的直接链接">​</a></h2><p>To briefly introduce the background, the Big Data platform has now completed the unification of the OLAP engine layer, using the StarRocks engine to replace the previous Kylin engine as the main query engine in OLAP scenarios.</p><p>In the data processing process, after the data is modelled in the data warehouse, the upper model needs to be imported into the OLAP engine for query acceleration, so there are a lot of tasks to push data from Hive to StarRocks every day. task (based on a wrapper for the StarRocks Broker Load import method) to a StarRocks-based table.</p><p>The current pain points are twofold.</p><p>·Long data synchronization links: Hive2StarRocks processing links, which require at least two tasks, are relatively redundant.</p><p>·Outbound efficiency: From the perspective of outbound efficiency, many Hive models themselves are processed by Spark SQL, and based on the processing the Spark Dataset in memory can be pushed directly to StarRocks without dropping the disk, improving the model’s regional time.</p><p><img loading="lazy" src="/zh-CN/assets/images/16714327218590-2644dc4ad1179eab81d40fc774d970e9.jpg" width="720" height="405" class="img_ev3q">
StarRocks currently also supports Spark Load, based on the Spark bulk data import method, but our ETL is more complex, needs to support data conversion multi-table Join, data aggregation operations, etc., so temporarily can not meet.</p><p>We know from the SeaTunnel community that there are plans to support the StarRocks Sink Connector, and we are working on that part as well, so we will continue to communicate with the community to build it together later.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-to-get-involved-in-community-building">How to get involved in community building<a href="#how-to-get-involved-in-community-building" class="hash-link" aria-label="How to get involved in community building的直接链接" title="How to get involved in community building的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="seatunnel-community-contribution">SeaTunnel Community Contribution<a href="#seatunnel-community-contribution" class="hash-link" aria-label="SeaTunnel Community Contribution的直接链接" title="SeaTunnel Community Contribution的直接链接">​</a></h3><p>As mentioned earlier, the community has completed the refactoring of the V1 to V2 API and needs to implement more connector plug-ins based on the V2 version of the connector API, which I was lucky enough to contribute to.</p><p>I am currently responsible for big data infrastructure work, which many mainstream big data components big data also use, so when the community proposed a connector issue, I was also very interested in it.</p><p>As the platform is also investigating SeaTunnel, learning and being able to contribute pr to the community is a great way to learn about SeaTunnel.</p><p>I remember at first I proposed a less difficult pr to implement the WeChat sink connector, but in the process of contributing I encountered many problems, bad coding style, code style did not take into account the rich output format supported by the extension, etc. Although the process was not so smooth, I was really excited and accomplished when the pr was merged. Although the process was not so smooth, it was very exciting and rewarding when the pr was merged.</p><p>As I became more familiar with the process, I became much more efficient at submitting pr and was confident enough to attempt difficult issues.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="how-to-get-involved-in-community-contributions-quickly">How to get involved in community contributions quickly<a href="#how-to-get-involved-in-community-contributions-quickly" class="hash-link" aria-label="How to get involved in community contributions quickly的直接链接" title="How to get involved in community contributions quickly的直接链接">​</a></h3><ul><li>Good first issue
Good first issue #3018 #2828</li></ul><p>If you are a first-time community contributor, it is advisable to focus on the Good first issue first, as it is basically a relatively simple and newcomer-friendly issue.</p><p>Through Good first issue, you can get familiar with the whole process of participating in the GitHub open source community contribution, for example, first fork the project, then submit the changes, and finally submit the pull request, waiting for the community to review, the community will target to you to put forward some suggestions for improvement, directly will leave a comment below, until when your pr is merged in, this will have completed a comp</p><ul><li>Subscribe to community mailings
Once you’re familiar with the pr contribution process, you can subscribe to community emails to keep up to date with what’s happening in the community, such as what features are currently being worked on and what’s planned for future iterations. If you’re interested in a feature, you can contribute to it in your own situation!</li><li>Familiarity with git use
The main git commands used in development are git clone, git pull, git rebase and git merge. git rebase is recommended in the community development specification and does not generate additional commits compared to git merge.</li><li>Familiarity with GitHub project collaboration process
Open source projects are developed collaboratively by multiple people, and the collaboration method on GitHub is at its core outlined in fork For example, the apache st project, which is under the apache space, is first forked to our own space on GitHub</li></ul><p>Then modify the implementation, mention a pull request, and submit the pull request to be associated with the issue, in the commit, if we change a long time, in the upward commit, then the target branch has a lot of new commits exhausted this time we need to do a pull&amp; merge or rebase.</p><ul><li>Source code compilation project
It is important to be familiar with source compilation, as local source compilation can prove that the code added to a project can be compiled, and can be used as a preliminary check before committing to pr. Source compilation is generally slow and can be speeded up by using mvn -T for multi-threaded parallel compilation.</li><li>Compilation checks
Pre-compilation checks, including Licence header, Code checkstyle, and Document checkstyle, will be checked during Maven compilation, and if they fail, the CI will not be passed. So it is recommended to use some plug-in tools in the idea to improve the efficiency, such as Code checkstyle has a plug-in to automatically check the code specification, Licence header can add code templates in the idea, these have been shared by the community before how to do!</li><li>Add full E2E</li></ul><p>Add full E2E testing and ensure that the E2E is passed before the Pull request.</p><p>Finally, I hope more students will join the SeaTunnel community, where you can not only feel the open-source spirit and culture of Apache but also understand the management process of Apache projects and learn good code design ideas.</p><p>We hope that by working together and growing together, we can build SeaTunnel into a top-notch data integration platform.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh-CN/blog/tags/meetup">Meetup</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="After days of community development, the preliminary development of the new Connector API of SeaTunnel is completed. The next step is to adapt this new connector. In order to aid the developers to use this connector, this article provides guide to develop a new API."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-CN/blog/Upcoming API Connector Development Analysis">Upcoming API Connector Development Analysis</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-06-23T00:00:00.000Z" itemprop="datePublished">2022年6月23日</time> · <!-- -->阅读需 4 分钟</div></header><div class="markdown" itemprop="articleBody"><p>After days of community development, the preliminary development of the new Connector API of SeaTunnel is completed. The next step is to adapt this new connector. In order to aid the developers to use this connector, this article provides guide to develop a new API.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="priliminary-setup">Priliminary Setup<a href="#priliminary-setup" class="hash-link" aria-label="Priliminary Setup的直接链接" title="Priliminary Setup的直接链接">​</a></h2><ul><li><p>Environment configuration: JDK8 and Scala2.11 are recommended.</p></li><li><p>As before, we need to download the latest code locally through git and import it into the IDE, project address: <a href="https://github.com/apache/incubator-seatunnel" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seatunnel</a> . At the same time, switch the branch to api-draft, and currently use this branch to develop the new version of the API and the corresponding Connector. The project structure is as follows:</p><p><img loading="lazy" alt="Project Structure" src="/zh-CN/assets/images/0-82b23e9c80c8b70ce10feaccfc96a2a6.png" width="583" height="1014" class="img_ev3q"></p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="prerequisites">Prerequisites<a href="#prerequisites" class="hash-link" aria-label="Prerequisites的直接链接" title="Prerequisites的直接链接">​</a></h2><ul><li><p>At present, in order to distinguish different Connectors, we put the connectors that support</p><ul><li>Flink/Spark under the <code>seatunnel-connectors/seatunnel-connectors-flink(spark)</code> module.</li><li>New version of the Connector is placed under the <code>seatunnel-connectors/seatunnel-connectors-seatunnel</code> module.</li></ul><p>As we can see from the above figure, we have implemented Fake, Console, Kafka Connector, and Clickhouse Connector is also being implemented.</p></li><li><p>At present, the data type we support is SeaTunnelRow, so no matter the type of data generated by the Source or the type of data consumed by the Sink, it should be SeaTunnelRow.</p></li></ul><h1>Development of Connector</h1><p>Taking Fake Connector as an example, let&#x27;s introduce how to implement a new Connector:</p><ul><li><p>Create a corresponding module with a path under <code>seatunnel-connectors-seatunnel</code>, which is at the same level as other new connectors.</p></li><li><p>Modify the <code>seatunnel-connectors-seatunnel/pom.xml</code> file, add a new module to modules, modify <code>seatunnel-connectors-seatunnel/seatunnel-connector-seatunnel-fake/pom.xml</code>, add seatunnel-api dependencies, and correct parent Quote. The resulting style is as follows:</p><p><img loading="lazy" alt="Style" src="/zh-CN/assets/images/1-27a269d360e9ee05b1dd696eeb0aa8e4.png" width="949" height="568" class="img_ev3q"></p></li><li><p>The next step is to create the corresponding package and related classes, create FakeSource, and need to inherit SeaTunnel Source.</p><ul><li>Note : The Source of SeaTunnel adopts the design of stream and batch integration. The Source of SeaTunnel determines whether current Source is a stream or batch through attribute getBoundedness.</li></ul><p>So you can specify a Source as a stream or batch by dynamic configuration (refer to the default method). The configuration defined by the user in the configuration file can be obtained through the prepare method to realize the customized configuration.</p><p>Then create FakeSourceReader, FakeSource SplitEnumerator, and FakeSourceSplit to inherit the corresponding abstract classes (which can be found in the corresponding classes). As long as we implement the corresponding methods of these classes, then our SeaTunnel Source Connector is basically completed.</p></li><li><p>Next, just follow the existing example to write the corresponding code. The most important one is the FakeSource Reader, which defines how we obtain data from the outside, which is the most critical part of the Source Connector. Every time a piece of data is generated, we need to place it in the collector as shown:</p><p><img loading="lazy" alt="Source" src="/zh-CN/assets/images/2-6e56482ef5f497868040295fe7edff23.png" width="935" height="424" class="img_ev3q"></p></li><li><p>After the code development is complete, we need to configure the configuration file <code>plugin-mapping.properties</code> located under <code>seatunnel-connectors/modules</code>. Adding a seatunnel
<code>.source.FakeSource = seatunnel-connector-fake</code>
means that SeaTunnel can find the jar package corresponding to the project by looking for a Source named FakeSource. This allows the Connector to be used in the normal configuration file.</p></li><li><p>For a detailed description of writing Source and Sink and SeaTunnel API, please refer to the introduction at <code>seatunnel-connectors/seatunnel-connectors-seatunnel/ README.zh.md</code>.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="connector-testing">Connector Testing<a href="#connector-testing" class="hash-link" aria-label="Connector Testing的直接链接" title="Connector Testing的直接链接">​</a></h2><ul><li>For testing, we can find the <code>seatunnel-flink(spark)-new-connector-example</code> module in seatunnel-examples, and test it against different engines to ensure that the performance of the Connector is as consistent as possible. If you find any discrepancies, you can mark them in the document, modify the configuration file under resource, add our Connector to the configuration, and introduce <code>seatunnel-flink(spark)-new-connector-example/pom.xml</code> dependency, you can execute <code>SeaTunnelApiExample</code> to test.</li><li>The default is stream processing mode, and the execution mode is switched to batch mode by modifying <code>job.mode=BATCH</code> in the environment of the configuration file.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="submit-pr">Submit PR<a href="#submit-pr" class="hash-link" aria-label="Submit PR的直接链接" title="Submit PR的直接链接">​</a></h2><p>When our Connector is ready, we can submit PR to github. After reviewing by other partners, our contributed Connector will become part of SeaTunnel!</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh-CN/blog/tags/meetup">Meetup</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="1"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/zh-CN/blog/智能化时代的数据集成技术革新">智能化时代的数据集成技术革新</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-04-08T00:00:00.000Z" itemprop="datePublished">2022年4月8日</time> · <!-- -->阅读需 5 分钟</div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" alt="1" src="/zh-CN/assets/images/1-3abb262dd4a58a521e31f7249b2058d2.png" width="900" height="383" class="img_ev3q"></p><p>可管理，可调用，可计算，可变现的数据资源才能成为资产，信息系统的互联互通使得多源和多维度的数据集成需求巨大，这就对数据处理和集成的工具提出了严苛的要求。</p><p>智能化时代，在“智慧城市”、“智慧治理”、“产品智能化”等的趋势下，企业大多面临如何实现高效数据推送，提高平台质量，以及保障数据安全的挑战。选对数据集成工具和平台，数据才能发挥出做大的作用。</p><p>Apache SeaTunnel (Incubating) 作为下一代高性能、分布式、海量数据集成框架，致力于让数据同步更简单，更高效，加快分布式数据处理能力在生产环境落地。</p><p>在 Apache SeaTunnel(Incubating) Meetup（2022 年 4 月 16日），Apache SeaTunnel(Incubating) 社区将邀请了 Apache SeaTunnel(Incubating)的资深用户，分享 Apache SeaTunnel(Incubating)在智能化生产环境中落地的最佳实践。此外，还会有贡献者现场进行 Apache SeaTunnel(Incubating)的源码解析，让你对 Apache SeaTunnel(Incubating)有一个更加全面而深入的了解。</p><p>无论你是对 Apache SeaTunnel(Incubating)抱有兴趣的初学者，还是在日常的生产实践中遭遇了复杂棘手的部署问题，都可以来到这里，与我们的讲师近距离沟通，得到你想要的答案。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="01-报-名-通-道">01 报 名 通 道<a href="#01-报-名-通-道" class="hash-link" aria-label="01 报 名 通 道的直接链接" title="01 报 名 通 道的直接链接">​</a></h2><p>Apache SeaTunnel (Incubating) Meetup | 4 月线上直播报名通道已开启，赶快预约吧！</p><p>时间：2022-4-16 14:00-17:00</p><p>形式：线上直播</p><p>点击链接或扫码预约报名（免费）：</p><p><img loading="lazy" alt="2" src="/zh-CN/assets/images/2-e9c01734f2c74a12f59e2f3eecd2a2c6.png" width="300" height="300" class="img_ev3q"></p><p>扫码预约报名</p><p><img loading="lazy" alt="3" src="/zh-CN/assets/images/4-b0dd1cb8a1432483e3f3202cbea5c271.png" width="498" height="507" class="img_ev3q"></p><p>扫码进直播群</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="02-活-动-亮-点">02 活 动 亮 点<a href="#02-活-动-亮-点" class="hash-link" aria-label="02 活 动 亮 点的直接链接" title="02 活 动 亮 点的直接链接">​</a></h2><ul><li>行业案例详解</li><li>特色功能分析</li><li>一线企业踩坑心得</li><li>开源社区实战攻略</li><li>行业技术专家面对面 Q&amp;A</li><li>惊喜礼品送不停</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="03-活-动-议-程">03 活 动 议 程<a href="#03-活-动-议-程" class="hash-link" aria-label="03 活 动 议 程的直接链接" title="03 活 动 议 程的直接链接">​</a></h2><p>活动当天，将有来自孩子王、oppo 的工程师现场分享来自厂商的一线前沿实践经验，还有来自白鲸开源的高级工程师对 Apache SeaTunnel(Incubating)的重要功能更新进行“硬核”讲解，干货满满。</p><p><img loading="lazy" alt="4" src="/zh-CN/assets/images/5-f80f0bce07f15e8f83f603d16825dde4.png" width="1080" height="1075" class="img_ev3q"></p><p>袁洪军 孩子王 大数据专家、OLAP 平台架构师</p><p>多年大数据平台研发管理经验，在数据资产、血缘图谱、数据治理、OLAP 等领域有着丰富的研究经验</p><p>演讲时间：14:00-14:40</p><p>演讲题目：Apache SeaTunnel(Incubating) 在孩子王的应用实践</p><p>演讲概要： 如何实现高效数据推送？如何提高平台质量？如何保障数据安全？孩子王又对 Apache SeaTunnel(Incubating)做了哪些改造？</p><p><img loading="lazy" alt="6" src="/zh-CN/assets/images/6-8f02c4507ef50d7a109ddf227c45a7a5.png" width="1080" height="1080" class="img_ev3q"></p><p>范佳 白鲸开源  高级工程师 Apache SeaTunnel Contributor</p><p>演讲时间： 14:40-15:20</p><p>演讲题目： 基于 Apache SeaTunnel(Incubating)的 Clickhouse Bulk Load 实现</p><p>演讲概要： 通过扩展 Apache SeaTunnel(Incubating)的 Connector实现 Clickhouse的 bulk load 数据同步功能。</p><p><img loading="lazy" alt="7" src="/zh-CN/assets/images/7-8b4c7798dd107093cb31b526eb3d8476.png" width="1080" height="1078" class="img_ev3q"></p><p>王子超 oppo 高级后端工程师</p><p>演讲时间： 15:50-16:30</p><p>演讲题目： oppo智能推荐样本中心基于 Apache SeaTunnel(Incubating)的技术革新</p><p>演讲概要： 介绍 oppo 智能推荐机器学习样本流程的演进及 Apache  SeaTunnel(Incubating) 在其中发挥的作用。</p><p>除了精彩的演讲之外，现场还设置了多个抽奖环节，参与抽奖有机会获得 Apache SeaTunnel(Incubating) 精美定制礼品，敬请期待~</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh-CN/blog/tags/meetup">Meetup</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="博文列表分页导航"></nav></main></div></div></div><footer class="footer"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">SeaTunnel</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/zh-CN/docs/faq">FAQ</a></li><li class="footer__item"><a href="https://github.com/apache/incubator-seatunnel/releases" target="_blank" rel="noopener noreferrer" class="footer__link-item">版本<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/apache/incubator-seatunnel" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/apache/incubator-seatunnel/issues" target="_blank" rel="noopener noreferrer" class="footer__link-item">Issue Tracker<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/apache/incubator-seatunnel/pulls" target="_blank" rel="noopener noreferrer" class="footer__link-item">Pull Requests<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">订阅邮件组</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/zh-CN/community/contribution_guide/subscribe">How to Subscribe</a></li><li class="footer__item"><a href="mailto:dev-subscribe@seatunnel.apache.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">订阅邮件<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://lists.apache.org/list.html?dev@seatunnel.apache.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">邮件归档<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright"><div style="margin-top: 20px;background: #f4f8fa">
                <img style="height:50px;margin-bottom: 10px" alt="Apache Software Foundation" src="/zh-CN/image/incubator-logo.svg">
                <p style="color: #999999;font-weight:400;text-align:left">Apache SeaTunnel is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.</p>
                <div style="border-top: 1px solid #ccc;min-height: 60px;line-height: 20px;text-align: center;font-family: Avenir-Medium;font-size: 14px;color: #999;display: flex;align-items: center;"><span>Copyright © 2021-2022 The Apache Software Foundation. Apache SeaTunnel, SeaTunnel, and its feather logo are trademarks of The Apache Software Foundation.</span></div>
                <div style="text-align: center;">
                    <a href="https://twitter.com/asfseatunnel?s=21" target="_blank" title="Twitter"><svg t="1644553365083" class="icon" viewBox="0 0 1260 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7015" width="25" height="25"><path d="M1259.846921 121.148242c-46.524504 20.728739-96.273478 34.547899-148.325646 40.536201 53.434084-31.784067 94.430924-82.454319 113.777747-142.797982-50.209613 29.480874-105.486251 51.13089-164.447999 62.646857A257.584528 257.584528 0 0 0 872.449815 0.000276c-142.797982 0-258.418284 115.620302-258.418284 258.418284 0 20.268101 2.303193 40.075563 6.909579 58.961748C405.82286 306.32498 215.579097 203.602561 87.98219 47.446058c-22.110655 38.233008-35.008538 82.454319-35.008538 129.900099 0 89.824537 45.603227 168.593747 115.159663 215.118251-42.378756-1.381916-81.99368-12.897882-117.002217-32.244706v3.224471c0 125.293713 88.90326 229.398049 207.287393 253.351259-21.650017 5.988302-44.681949 9.212773-68.17452 9.212773-16.582991 0-32.705344-1.842555-48.827697-4.606387 32.705344 102.722419 128.518184 177.345881 241.374653 179.649074-88.442621 69.095798-199.917175 110.553277-321.06514 110.553277-20.728739 0-41.457479-1.381916-61.72558-3.685109 114.238386 73.241546 250.126788 116.08094 396.149241 116.08094 475.379089 0 735.179289-393.846048 735.179289-735.179289 0-11.055328-0.460639-22.571294-0.921277-33.626621 51.13089-36.851092 94.891562-82.454319 129.439461-134.045848z" fill="#909094" p-id="7016"></path></svg></a> 
                    <a href="https://apacheseatunnel.slack.com" target="_blank" title="Slack" style="margin-left: 20px;"><svg t="1644553076784" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3088" width="23" height="23"><path d="M215.125333 647.04a107.861333 107.861333 0 0 1-107.52 107.648A107.861333 107.861333 0 0 1 0 647.04a107.818667 107.818667 0 0 1 107.605333-107.52h107.52v107.52z m54.229334 0a107.818667 107.818667 0 0 1 107.562666-107.52 107.818667 107.818667 0 0 1 107.562667 107.52v269.354667A107.861333 107.861333 0 0 1 376.917333 1024a107.861333 107.861333 0 0 1-107.562666-107.605333v-269.354667zM376.917333 215.125333a107.861333 107.861333 0 0 1-107.562666-107.52A107.861333 107.861333 0 0 1 376.917333 0a107.861333 107.861333 0 0 1 107.562667 107.605333v107.52H376.917333z m0 54.229334a107.861333 107.861333 0 0 1 107.562667 107.562666 107.861333 107.861333 0 0 1-107.562667 107.562667H107.605333A107.861333 107.861333 0 0 1 0 376.917333a107.861333 107.861333 0 0 1 107.605333-107.562666h269.312z m431.872 107.562666a107.861333 107.861333 0 0 1 107.605334-107.562666A107.861333 107.861333 0 0 1 1024 376.917333a107.861333 107.861333 0 0 1-107.605333 107.562667h-107.605334V376.917333z m-54.101333 0a107.861333 107.861333 0 0 1-107.648 107.562667 107.818667 107.818667 0 0 1-107.52-107.562667V107.605333A107.818667 107.818667 0 0 1 647.04 0a107.861333 107.861333 0 0 1 107.648 107.605333v269.312z m-107.648 431.872a107.861333 107.861333 0 0 1 107.648 107.605334A107.861333 107.861333 0 0 1 647.04 1024a107.818667 107.818667 0 0 1-107.52-107.605333v-107.605334h107.52z m0-54.101333a107.818667 107.818667 0 0 1-107.52-107.648 107.776 107.776 0 0 1 107.52-107.52h269.354667A107.818667 107.818667 0 0 1 1024 647.04a107.861333 107.861333 0 0 1-107.605333 107.648h-269.354667z" p-id="3089" fill="#909094"></path></svg></a> 
                    <a href="https://lists.apache.org/list.html?dev@seatunnel.apache.org" target="_blank" title="Mailing list" style="margin-left: 20px;"><svg t="1644553175467" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5304" width="26" height="26"><path d="M853.333333 170.666667H170.666667c-46.933333 0-85.333333 38.4-85.333334 85.333333v512c0 46.933333 38.4 85.333333 85.333334 85.333333h682.666666c46.933333 0 85.333333-38.4 85.333334-85.333333V256c0-46.933333-38.4-85.333333-85.333334-85.333333z m0 170.666666l-341.333333 213.333334-341.333333-213.333334V256l341.333333 213.333333 341.333333-213.333333v85.333333z" p-id="5305" fill="#909094"></path></svg></a> 
                    <a href="https://github.com/apache/incubator-seatunnel" target="_blank" title="GitHub" style="margin-left: 20px;"><svg t="1644553223000" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6156" width="23" height="23"><path d="M512 12.64c-282.752 0-512 229.216-512 512 0 226.208 146.72 418.144 350.144 485.824 25.6 4.736 35.008-11.104 35.008-24.64 0-12.192-0.48-52.544-0.704-95.328-142.464 30.976-172.512-60.416-172.512-60.416-23.296-59.168-56.832-74.912-56.832-74.912-46.464-31.776 3.52-31.136 3.52-31.136 51.392 3.616 78.464 52.768 78.464 52.768 45.664 78.272 119.776 55.648 148.992 42.56 4.576-33.088 17.856-55.68 32.512-68.48-113.728-12.928-233.28-56.864-233.28-253.024 0-55.904 20-101.568 52.768-137.44-5.312-12.896-22.848-64.96 4.96-135.488 0 0 43.008-13.76 140.832 52.48a491.296 491.296 0 0 1 128.16-17.248c43.488 0.192 87.328 5.888 128.256 17.248 97.728-66.24 140.64-52.48 140.64-52.48 27.872 70.528 10.336 122.592 5.024 135.488 32.832 35.84 52.704 81.536 52.704 137.44 0 196.64-119.776 239.936-233.792 252.64 18.368 15.904 34.72 47.04 34.72 94.816 0 68.512-0.608 123.648-0.608 140.512 0 13.632 9.216 29.6 35.168 24.576C877.472 942.624 1024 750.784 1024 524.64c0-282.784-229.248-512-512-512z" p-id="6157" fill="#909094"></path></svg></a> 
                </div>
            <div></div></div></div></div></div></footer></div>
<script src="/zh-CN/assets/js/runtime~main.493b0a68.js"></script>
<script src="/zh-CN/assets/js/main.ae1b2d26.js"></script>
</body>
</html>